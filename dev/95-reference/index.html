<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · KagomeDSL.jl</title><meta name="title" content="Reference · KagomeDSL.jl"/><meta property="og:title" content="Reference · KagomeDSL.jl"/><meta property="twitter:title" content="Reference · KagomeDSL.jl"/><meta name="description" content="Documentation for KagomeDSL.jl."/><meta property="og:description" content="Documentation for KagomeDSL.jl."/><meta property="twitter:description" content="Documentation for KagomeDSL.jl."/><meta property="og:url" content="https://hz-xiaxz.github.io/KagomeDSL.jl/95-reference/"/><meta property="twitter:url" content="https://hz-xiaxz.github.io/KagomeDSL.jl/95-reference/"/><link rel="canonical" href="https://hz-xiaxz.github.io/KagomeDSL.jl/95-reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KagomeDSL.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">KagomeDSL</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/main/docs/src/95-reference.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="reference"><a class="docs-heading-anchor" href="#reference">Reference</a><a id="reference-1"></a><a class="docs-heading-anchor-permalink" href="#reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}"><code>KagomeDSL.DoubleKagome</code></a></li><li><a href="#KagomeDSL.Hamiltonian"><code>KagomeDSL.Hamiltonian</code></a></li><li><a href="#KagomeDSL.Hamiltonian-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:KagomeDSL.AbstractLattice"><code>KagomeDSL.Hamiltonian</code></a></li><li><a href="#KagomeDSL.MC-Tuple{AbstractDict}"><code>KagomeDSL.MC</code></a></li><li><a href="#KagomeDSL.MC-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}, AbstractMatrix, AbstractMatrix}"><code>KagomeDSL.MC</code></a></li><li><a href="#Carlo.init!-Tuple{MC, MCContext, AbstractDict}"><code>Carlo.init!</code></a></li><li><a href="#Carlo.read_checkpoint!-Tuple{MC, HDF5.Group}"><code>Carlo.read_checkpoint!</code></a></li><li><a href="#Carlo.register_evaluables-Tuple{Type{MC}, Carlo.Evaluator, AbstractDict}"><code>Carlo.register_evaluables</code></a></li><li><a href="#Carlo.sweep!-Tuple{MC, MCContext}"><code>Carlo.sweep!</code></a></li><li><a href="#Carlo.write_checkpoint-Tuple{MC, HDF5.Group}"><code>Carlo.write_checkpoint</code></a></li><li><a href="#KagomeDSL.Hmat-Tuple{DoubleKagome}"><code>KagomeDSL.Hmat</code></a></li><li><a href="#KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.Sz</code></a></li><li><a href="#KagomeDSL.SzInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}"><code>KagomeDSL.SzInteraction!</code></a></li><li><a href="#KagomeDSL.apply_boundary_conditions!-Tuple{AbstractMatrix, KagomeDSL.AbstractLattice, Int64, Int64, Dict, Float64}"><code>KagomeDSL.apply_boundary_conditions!</code></a></li><li><a href="#KagomeDSL.find_initial_configuration!-Tuple{MC, Int64, Int64}"><code>KagomeDSL.find_initial_configuration!</code></a></li><li><a href="#KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.getOL</code></a></li><li><a href="#KagomeDSL.get_boundary_shifts-Tuple{KagomeDSL.AbstractLattice, Int64, Int64}"><code>KagomeDSL.get_boundary_shifts</code></a></li><li><a href="#KagomeDSL.get_nn-Tuple{AbstractMatrix}"><code>KagomeDSL.get_nn</code></a></li><li><a href="#KagomeDSL.get_site_coord-Tuple{KagomeDSL.AbstractLattice, Int64}"><code>KagomeDSL.get_site_coord</code></a></li><li><a href="#KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.getxprime</code></a></li><li><a href="#KagomeDSL.init_conf_qr!-Tuple{MC, Int64, Int64}"><code>KagomeDSL.init_conf_qr!</code></a></li><li><a href="#KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}"><code>KagomeDSL.is_occupied</code></a></li><li><a href="#KagomeDSL.orbitals-Tuple{Matrix{ComplexF64}, Int64, Int64}"><code>KagomeDSL.orbitals</code></a></li><li><a href="#KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}"><code>KagomeDSL.spinInteraction!</code></a></li><li><a href="#KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}"><code>KagomeDSL.tilde_U</code></a></li><li><a href="#KagomeDSL.unitcell_coord-Tuple{KagomeDSL.AbstractLattice, Int64}"><code>KagomeDSL.unitcell_coord</code></a></li><li><a href="#KagomeDSL.unitcell_diff-Tuple{KagomeDSL.AbstractLattice, Vector{Float64}, Vector{Float64}}"><code>KagomeDSL.unitcell_diff</code></a></li><li><a href="#KagomeDSL.update_W!-Tuple{AbstractMatrix, Int64, Int64, AbstractVector, AbstractVector}"><code>KagomeDSL.update_W!</code></a></li><li><a href="#KagomeDSL.update_W_matrices!-Tuple{MC}"><code>KagomeDSL.update_W_matrices!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}" href="#KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}"><code>KagomeDSL.DoubleKagome</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DoubleKagome(t::Float64, n1::Int, n2::Int, PBC::Tuple{Bool,Bool}; antiPBC=(false,false), trunc=Inf)</code></pre><p>Construct a double unit cell Kagome lattice with 6 sites per unit cell.</p><p>Unlike a single unit cell Kagome lattice (which has 3 sites per unit cell forming one triangle), the DoubleKagome lattice contains 6 sites per unit cell arranged in two triangular sublattices. This structure is useful for studying systems with enlarged unit cells or specific magnetic ordering patterns that require the doubled cell geometry.</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Parameter defining the equilateral triangle side length (lattice constant = 2t)</li><li><code>n1::Int</code>: Number of unit cell repetitions in the a1 direction (must be even)</li><li><code>n2::Int</code>: Number of unit cell repetitions in the a2 direction  </li><li><code>PBC::Tuple{Bool,Bool}</code>: Periodic boundary conditions in (a1, a2) directions</li><li><code>antiPBC::Tuple{Bool,Bool}</code>: Antiperiodic boundary conditions (default: (false, false))</li><li><code>trunc::Float64</code>: Truncation parameter (default: Inf, unused in current implementation)</li></ul><p><strong>Returns</strong></p><ul><li><code>DoubleKagome</code>: Lattice structure with <code>n1 * n2 * 3</code> total sites</li></ul><p><strong>Notes</strong></p><ul><li>The constraint <code>n1 % 2 == 0</code> ensures proper tiling of the double unit cell</li><li>Total number of sites is <code>n1 * n2 * 3</code> (though each unit cell has 6 sites, <code>n1</code> counts double-sized cells)</li><li>Actual number of unit cells is <code>(n1 ÷ 2) * n2</code>, each containing 6 sites</li><li>Lattice vectors: a1 = [4t, 0], a2 = [t, √3*t] </li><li>Each unit cell contains 6 sites arranged in two triangular motifs</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a 4×3 DoubleKagome lattice with periodic boundaries
lat = DoubleKagome(1.0, 4, 3, (true, true))
# Total sites: 4 * 3 * 3 = 36 sites (2 unit cells × 3 repetitions × 6 sites per unit cell)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Lattice.jl#L33-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.Hamiltonian" href="#KagomeDSL.Hamiltonian"><code>KagomeDSL.Hamiltonian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hamiltonian</code></pre><p>Complete specification of the spinon mean-field Hamiltonian for quantum Monte Carlo simulations.</p><p>This structure contains all information needed for Variational  Monte Carlo calculations of quantum spin liquid properties:</p><p><strong>Fields</strong></p><ul><li><code>N_up::Int</code>: Number of up-spin spinons (determines spin sector)</li><li><code>N_down::Int</code>: Number of down-spin spinons</li><li><code>U_up::Matrix{ComplexF64}</code>: Occupied up-spinon orbitals (columns are eigenvectors)</li><li><code>U_down::Matrix{ComplexF64}</code>: Occupied down-spinon orbitals</li><li><code>H_mat::Matrix{ComplexF64}</code>: Single-particle spinon Hamiltonian matrix</li><li><code>nn::AbstractArray</code>: List of nearest-neighbor bonds for efficient iteration</li></ul><p><strong>Usage in Monte Carlo</strong></p><ul><li>U<em>up, U</em>down define the reference state (filled Fermi sea)</li><li>H_mat provides the hopping amplitudes for Monte Carlo updates</li><li>nn specifies which bonds to consider in interaction terms</li></ul><p><strong>Physical Interpretation</strong></p><ul><li>Represents a quantum spin liquid state where spins are fractionalized</li><li>Correlations arise from quantum fluctuations around the mean-field state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L395-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.Hamiltonian-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:KagomeDSL.AbstractLattice" href="#KagomeDSL.Hamiltonian-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:KagomeDSL.AbstractLattice"><code>KagomeDSL.Hamiltonian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hamiltonian(N_up, N_down, lat; link_in=pi_link_in, link_inter=pi_link_inter, B=0.0)</code></pre><p>Construct a complete Hamiltonian structure for quantum Monte Carlo simulations.</p><p>This is the main constructor that builds everything needed for SSE Monte Carlo:</p><ol><li>Constructs the single-particle spinon Hamiltonian matrix</li><li>Diagonalizes it to find the occupied orbitals</li><li>Extracts the nearest-neighbor bond structure</li><li>Packages everything for efficient Monte Carlo usage</li></ol><p><strong>Arguments</strong></p><ul><li><code>N_up::Int, N_down::Int</code>: Number of up/down spinons (determines magnetic sector)</li><li><code>lat::AbstractLattice</code>: Lattice structure (typically DoubleKagome)</li><li><code>link_in</code>: Intra-cell hopping dictionary (default: π-flux pattern)</li><li><code>link_inter</code>: Inter-cell hopping dictionary (default: π-flux pattern)</li><li><code>B::Float64</code>: Magnetic field strength for Peierls phases (default: 0.0)</li></ul><p><strong>Returns</strong></p><ul><li><code>Hamiltonian</code>: Complete structure ready for Monte Carlo simulations</li></ul><p><strong>Physics Notes</strong></p><ul><li>The choice of N<em>up, N</em>down determines the spin sector being studied</li><li>For spin-1/2 systems: N<em>up + N</em>down = number of original spins</li><li>Different (N<em>up, N</em>down) can access different quantum phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L454-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.MC-Tuple{AbstractDict}" href="#KagomeDSL.MC-Tuple{AbstractDict}"><code>KagomeDSL.MC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MC(params::AbstractDict)</code></pre><hr/><p>Create a Monte Carlo object from a dictionary of parameters. This is the user-facing, high-level constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.MC-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}, AbstractMatrix, AbstractMatrix}" href="#KagomeDSL.MC-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}, AbstractMatrix, AbstractMatrix}"><code>KagomeDSL.MC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MC(Ham, kappa_up, kappa_down, W_up, W_down)</code></pre><hr/><p>Create a Monte Carlo object from its core components. This constructor automatically creates the necessary cache arrays. It&#39;s useful for internal logic and testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L107-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.init!-Tuple{MC, MCContext, AbstractDict}" href="#Carlo.init!-Tuple{MC, MCContext, AbstractDict}"><code>Carlo.init!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.init!(mc::MC, ctx::MCContext, params::AbstractDict)</code></pre><hr/><p>Initialize the Monte Carlo object <code>params</code></p><ul><li><code>n1</code> : <code>Int</code> number of cells in x direction</li><li><code>n2</code> : <code>Int</code> number of cells in y direction</li><li><code>PBC</code> : <code>Tuple{Bool,2}</code> boundary condition, e.g. (false, false)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L272-L280">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.read_checkpoint!-Tuple{MC, HDF5.Group}" href="#Carlo.read_checkpoint!-Tuple{MC, HDF5.Group}"><code>Carlo.read_checkpoint!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.read_checkpoint!(mc::MC, in::HDF5.Group)</code></pre><p>Restore Monte Carlo state from saved checkpoint for simulation continuation.</p><p><strong>Purpose</strong>: Loads previously saved spinon configurations to resume a simulation  from a specific state or initialize postprocessing analysis.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo object to restore (modified in-place)</li><li><code>in::HDF5.Group</code>: Input HDF5 group containing checkpoint data</li></ul><p><strong>Restored Data</strong></p><ul><li><code>kappa_up</code>: Up-spinon configuration vector</li><li><code>kappa_down</code>: Down-spinon configuration vector</li></ul><p><strong>Usage Contexts</strong></p><ol><li><strong>Simulation resumption</strong>: Continue interrupted long simulations</li><li><strong>Postprocessing initialization</strong>: Start analysis from specific configurations</li><li><strong>Reproducibility</strong>: Restore exact simulation states</li></ol><p><strong>Side Effects</strong></p><ul><li>Modifies mc.kappa<em>up and mc.kappa</em>down in-place</li><li>Overwrites current Monte Carlo configuration completely</li></ul><p><strong>Notes</strong></p><ul><li>Called automatically by Carlo.jl when resuming from checkpoints  </li><li>Essential for maintaining simulation continuity</li><li>Enables reproducible analysis workflows</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L497-L527">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.register_evaluables-Tuple{Type{MC}, Carlo.Evaluator, AbstractDict}" href="#Carlo.register_evaluables-Tuple{Type{MC}, Carlo.Evaluator, AbstractDict}"><code>Carlo.register_evaluables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.register_evaluables(::Type{MC}, eval::Evaluator, params::AbstractDict)</code></pre><p>Register postprocessing evaluators for final analysis after Monte Carlo simulation.</p><p><strong>IMPORTANT: This is purely for postprocessing</strong> - these evaluators are executed  at the end of the simulation or during merge operations to compute final observables  from the collected raw measurements. They do NOT affect the Monte Carlo dynamics.</p><p>This function defines how to compute physical observables from the raw measured  data (:OL values) that was collected during the simulation via Carlo.measure!().</p><p><strong>Arguments</strong></p><ul><li><code>::Type{MC}</code>: Monte Carlo type dispatch</li><li><code>eval::Evaluator</code>: Carlo.jl evaluator for postprocessing computations</li><li><code>params::AbstractDict</code>: Simulation parameters containing lattice dimensions</li></ul><p><strong>Registered Evaluables</strong></p><ul><li><code>:energy</code>: Computes the energy per site from local energy measurements<ul><li>Formula: energy = ⟨OL⟩ / ns, where ns = total number of sites</li><li>Input: Raw :OL measurements collected during simulation</li><li>Output: Normalized energy per site for final results</li></ul></li></ul><p><strong>Usage in Carlo.jl Workflow</strong></p><ol><li><strong>During simulation</strong>: Carlo.measure!() collects raw :OL data</li><li><strong>After simulation</strong>: This function defines how to postprocess the data</li><li><strong>Final analysis</strong>: Carlo.jl automatically applies these evaluators to compute final results</li><li><strong>Merge operations</strong>: Used when combining data from multiple simulation runs</li></ol><p><strong>Physics Notes</strong></p><ul><li>OL represents the local energy estimator ⟨x|H|ψ<em>G⟩/⟨x|ψ</em>G⟩</li><li>Normalization by ns gives energy per site (intensive quantity)</li><li>Essential for comparing results across different system sizes</li></ul><p><strong>Performance Notes</strong></p><ul><li>Called only once during setup, not during simulation loops</li><li>Actual evaluation happens in postprocessing phase</li><li>Minimal computational overhead during Monte Carlo sampling</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L412-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.sweep!-Tuple{MC, MCContext}" href="#Carlo.sweep!-Tuple{MC, MCContext}"><code>Carlo.sweep!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.sweep!(mc::MC, ctx::MCContext) -&gt; Nothing</code></pre><p>Perform one Monte Carlo sweep for the Mott state simulation. This implements a two-spin swap update where electrons can exchange positions between different spin states at occupied sites.</p><p>Note: The W matrices are re-evaluated periodically (every n_occupied sweeps) to maintain numerical stability. If the re-evaluation fails due to singular matrices, a warning is issued and the simulation continues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L321-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.write_checkpoint-Tuple{MC, HDF5.Group}" href="#Carlo.write_checkpoint-Tuple{MC, HDF5.Group}"><code>Carlo.write_checkpoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.write_checkpoint(mc::MC, out::HDF5.Group)</code></pre><p>Save Monte Carlo state for resuming simulations or postprocessing analysis.</p><p><strong>Purpose</strong>: Serializes the current spinon configuration to an HDF5 file for later  use in simulation continuation or postprocessing workflows.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo state to save</li><li><code>out::HDF5.Group</code>: Output HDF5 group for writing checkpoint data</li></ul><p><strong>Saved Data</strong></p><ul><li><code>kappa_up</code>: Current up-spinon configuration vector</li><li><code>kappa_down</code>: Current down-spinon configuration vector</li></ul><p><strong>Usage Contexts</strong></p><ol><li><strong>Simulation checkpointing</strong>: Save state for restarting long simulations</li><li><strong>Postprocessing</strong>: Preserve final configurations for additional analysis</li><li><strong>Data archival</strong>: Store representative configurations for later study</li></ol><p><strong>Notes</strong></p><ul><li>Called automatically by Carlo.jl during simulation checkpointing</li><li>Essential for resuming interrupted simulations</li><li>Enables analysis of specific configurations post-simulation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L465-L491">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.Hmat-Tuple{DoubleKagome}" href="#KagomeDSL.Hmat-Tuple{DoubleKagome}"><code>KagomeDSL.Hmat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hmat(
    lat::DoubleKagome;
    link_in = pi_link_in,
    link_inter = pi_link_inter,
    B = 0.0,
) -&gt; Matrix{ComplexF64}</code></pre><p>Constructs the Spinon Hamiltonian matrix for a <code>DoubleKagome</code> lattice.</p><p>This function calculates the hopping terms within and between unit cells, incorporating a Peierls phase to account for a magnetic field <code>B</code>. The resulting matrix represents the Hamiltonian of the system.</p><p><strong>Arguments</strong></p><ul><li><code>lat::DoubleKagome</code>: The lattice structure for which to construct the Hamiltonian.</li><li><code>link_in</code>: A dictionary defining in-cell hopping terms. Defaults to <code>pi_link_in</code>.</li><li><code>link_inter</code>: A dictionary defining inter-cell hopping terms. Defaults to <code>pi_link_inter</code>.</li><li><code>B::Float64</code>: The magnetic field strength, used to calculate the Peierls phase. Defaults to <code>0.0</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{ComplexF64}</code>: The Hamiltonian matrix for the given lattice and parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L285-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}" href="#KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.Sz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sz(i::Int, kappa_up::Vector{Int}, kappa_down::Vector{Int}) -&gt; Float64</code></pre><p>Calculate the z-component of spin at site <code>i</code> in the spinon representation.</p><p>In the spinon formulation, the original spin operators are written as:</p><ul><li>S^z<em>i = 1/2 (f^†</em>{i↑} f<em>{i↑} - f^†</em>{i↓} f_{i↓})</li><li>S^+<em>i = f^†</em>{i↑} f<em>{i↓}, S^-</em>i = f^†<em>{i↓} f</em>{i↑}</li></ul><p>where f<em>{iσ} are spinon annihilation operators. The constraint is exactly one  spinon per site: n</em>{i↑} + n_{i↓} = 1 (no double occupancy or empty sites).</p><p><strong>Arguments</strong></p><ul><li><code>i::Int</code>: Site index (1-indexed)</li><li><code>kappa_up::Vector{Int}</code>: Up-spinon configuration (0 = empty, nonzero = occupied)</li><li><code>kappa_down::Vector{Int}</code>: Down-spinon configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: +0.5 for up spin, -0.5 for down spin</li></ul><p><strong>Exceptions</strong></p><ul><li><code>ArgumentError</code>: If site is doubly occupied or empty (violates spinon constraint)</li><li><code>BoundsError</code>: If i is outside valid range [1, length(kappa_up)]</li><li><code>DimensionMismatch</code>: If kappa<em>up and kappa</em>down have different lengths</li></ul><p><strong>Physics Notes</strong></p><ul><li>This enforces the constraint that each site has exactly one spinon</li><li>Configurations violating the constraint (empty or doubly occupied) are unphysical</li><li>Used in Monte Carlo to measure local magnetization and Ising interactions</li><li>The spinon constraint is fundamental to the validity of the spin liquid state</li></ul><p><strong>Performance Notes</strong></p><ul><li>Marked @inline for performance in Monte Carlo loops</li><li>Uses @boundscheck for optional bounds checking</li><li>Calls is_occupied() helper function for spinon occupancy detection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L495-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.SzInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}" href="#KagomeDSL.SzInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}"><code>KagomeDSL.SzInteraction!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SzInteraction!(xprime, kappa_up, kappa_down, i, j)</code></pre><p>Compute the Ising (S^z S^z) interaction term for the Heisenberg Hamiltonian.</p><p>For the Heisenberg model H = J ∑<em>{&lt;i,j&gt;} (S^+</em>i S^-<em>j + S^-</em>i S^+<em>j + S^z</em>i S^z<em>j), this function handles the S^z</em>i S^z_j term, which is diagonal in the spinon basis.</p><p>The Ising term doesn&#39;t change the spinon configuration, so it contributes to the identity component of the operator expansion (stored with key (-1,-1,-1,-1)).</p><p><strong>Arguments</strong></p><ul><li><code>xprime::Dict</code>: Dictionary storing operator expansion coefficients</li><li><code>kappa_up::Vector{Int}</code>: Current up-spinon configuration</li><li><code>kappa_down::Vector{Int}</code>: Current down-spinon configuration  </li><li><code>i::Int, j::Int</code>: Sites for the interaction</li></ul><p><strong>Side Effects</strong></p><ul><li>Modifies xprime[(-1,-1,-1,-1)] by adding Sz(i) * Sz(j)</li></ul><p><strong>Physics Notes</strong></p><ul><li>This is the &quot;easy-axis&quot; part of the Heisenberg interaction</li><li>Diagonal in the occupation basis, doesn&#39;t create/destroy spinons</li><li>Combined with spinInteraction!() to give the full Heisenberg model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L568-L593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.apply_boundary_conditions!-Tuple{AbstractMatrix, KagomeDSL.AbstractLattice, Int64, Int64, Dict, Float64}" href="#KagomeDSL.apply_boundary_conditions!-Tuple{AbstractMatrix, KagomeDSL.AbstractLattice, Int64, Int64, Dict, Float64}"><code>KagomeDSL.apply_boundary_conditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_boundary_conditions!(tunneling, lat, s1, s2, link_inter, B)</code></pre><p>Apply boundary conditions and magnetic field effects to inter-cell hopping terms.</p><p>This function modifies the tunneling matrix by adding all possible hopping paths  between sites s1 and s2, considering:</p><ol><li>Periodic/antiperiodic boundary conditions</li><li>Peierls phase factors from magnetic field B</li><li>π-flux pattern encoded in link_inter dictionary</li></ol><p><strong>Arguments</strong></p><ul><li><code>tunneling::AbstractMatrix</code>: Hopping matrix to be modified (in-place)</li><li><code>lat::AbstractLattice</code>: Lattice structure with boundary conditions</li><li><code>s1::Int, s2::Int</code>: Source and target site indices</li><li><code>link_inter::Dict</code>: Inter-cell hopping amplitudes with (label1, label2, dx, dy) keys</li><li><code>B::Float64</code>: Magnetic field strength for Peierls phase calculation</li></ul><p><strong>Physics Details</strong></p><ul><li>Peierls phase: exp(iB/2 * (x1+x2)(y2-y1)) accounts for vector potential A = (0, Bx)</li><li>Each boundary crossing can contribute ±1 phase factor from antiperiodic BC</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L155-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.find_initial_configuration!-Tuple{MC, Int64, Int64}" href="#KagomeDSL.find_initial_configuration!-Tuple{MC, Int64, Int64}"><code>KagomeDSL.find_initial_configuration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_initial_configuration!(mc::MC, rng::AbstractRNG, ns::Int, N_up::Int, n1::Int)</code></pre><p>Finds a non-singular initial configuration for the MC simulation. This version uses a deterministic QR-based method and should not require retries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L235-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}" href="#KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.getOL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getOL(mc::AbstractMC, kappa_up, kappa_down) -&gt; Float64</code></pre><p>Compute the local energy estimator for quantum Monte Carlo.</p><p>Calculates the observable O<em>L = ⟨x|H|ψ</em>G⟩/⟨x|ψ_G⟩, which provides an unbiased estimator of the ground state energy in the Stochastic Series Expansion method.</p><p>In the spinon mean-field framework:</p><ul><li>|ψ_G⟩ is the Slater Determinant spinon state (Gutzwiller projected)</li><li>|x⟩ = |κ<em>up⟩ ⊗ |κ</em>down⟩ is a particular spinon configuration</li><li>H is the original Heisenberg Hamiltonian (not the mean-field one!)</li></ul><p>The ratio gives the local contribution to the energy from configuration |x⟩.</p><p><strong>Arguments</strong></p><ul><li><code>mc::AbstractMC</code>: Monte Carlo state containing W<em>up, W</em>down matrices</li><li><code>kappa_up::Vector{Int}</code>: Current up-spinon configuration</li><li><code>kappa_down::Vector{Int}</code>: Current down-spinon configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Local energy contribution from this configuration</li></ul><p><strong>Algorithm</strong></p><ol><li>Compute H|x⟩ using getxprime() to get all reachable configurations</li><li>For diagonal terms: directly add the Ising contributions</li><li>For off-diagonal terms: weight by the wavefunction amplitude ratios W<em>up, W</em>down</li><li>Sum all contributions to get the local energy</li></ol><p><strong>Physics Notes</strong></p><ul><li>This is the &quot;local energy&quot; in variational Monte Carlo terminology</li><li>Fluctuations in O_L reflect the quality of the trial wavefunction</li><li>Used to measure energy and other observables in quantum spin liquids</li><li>The Hamiltonian H must be the original physical one, not the mean-field approximation</li></ul><p><strong>Performance Notes</strong></p><ul><li>Critical function called in every Monte Carlo step</li><li>Bounds checking disabled with @inbounds for performance</li><li>Uses efficient iteration over pairs() for dictionary access</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L722-L762">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.get_boundary_shifts-Tuple{KagomeDSL.AbstractLattice, Int64, Int64}" href="#KagomeDSL.get_boundary_shifts-Tuple{KagomeDSL.AbstractLattice, Int64, Int64}"><code>KagomeDSL.get_boundary_shifts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_boundary_shifts(lat::AbstractLattice, s1::Int, s2::Int) -&gt; Vector{Tuple{Int,Int,Float64}}</code></pre><p>Calculate all possible lattice vector shifts between sites s1 and s2 under periodic/antiperiodic boundary conditions.</p><p>For quantum spin systems with twisted boundary conditions:</p><ul><li>Periodic BC: ψ(r + L) = ψ(r)</li><li>Antiperiodic BC: ψ(r + L) = -ψ(r)</li></ul><p>Returns all equivalent separations considering lattice periodicity, with associated phase factors.</p><p><strong>Arguments</strong></p><ul><li><code>lat::AbstractLattice</code>: Lattice with boundary condition specifications</li><li><code>s1::Int, s2::Int</code>: Site indices for the hopping term</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{Int,Int,Float64}}</code>: List of (dx, dy, sign) tuples where:<ul><li><code>dx, dy</code>: Lattice vector coefficients</li><li><code>sign</code>: Phase factor (±1) from antiperiodic boundary crossings</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L79-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.get_nn-Tuple{AbstractMatrix}" href="#KagomeDSL.get_nn-Tuple{AbstractMatrix}"><code>KagomeDSL.get_nn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nn(H_mat::AbstractMatrix) -&gt; Vector{Tuple{Int,Int}}</code></pre><p>Extract nearest-neighbor bond list from the Hamiltonian matrix.</p><p>Finds all non-zero off-diagonal elements in the upper triangular part of H_mat, which correspond to hopping terms between connected sites. Essential for efficient Monte Carlo sampling since we only need to consider active bonds.</p><p><strong>Arguments</strong></p><ul><li><code>H_mat::AbstractMatrix</code>: Hamiltonian matrix (typically hermitian)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{Int,Int}}</code>: List of (i,j) pairs where i &lt; j and H_mat[i,j] ≠ 0</li></ul><p><strong>Notes</strong></p><ul><li>Only upper triangular elements to avoid double-counting</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L429-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.get_site_coord-Tuple{KagomeDSL.AbstractLattice, Int64}" href="#KagomeDSL.get_site_coord-Tuple{KagomeDSL.AbstractLattice, Int64}"><code>KagomeDSL.get_site_coord</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_site_coord(lat::AbstractLattice, s::Int) -&gt; Vector{Float64}</code></pre><p>Calculate the real-space coordinate of site <code>s</code> in the lattice.</p><p>Combines the unit cell position with the intra-cell site offset to give the absolute position in real space. Essential for calculating Peierls phases and analyzing spatial correlations.</p><p><strong>Arguments</strong></p><ul><li><code>lat::AbstractLattice</code>: Lattice structure</li><li><code>s::Int</code>: Site index (1-indexed)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: [x, y] coordinate in real space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L263-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}" href="#KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.getxprime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getxprime(Ham::Hamiltonian, kappa_up, kappa_down) -&gt; Dict{NTuple{4,Int}, Float64}</code></pre><p>Compute the action of the Heisenberg Hamiltonian on a spinon configuration.</p><p>This is the core function for Stochastic Series Expansion (SSE) Monte Carlo. Given a spinon configuration |κ<em>up, κ</em>down⟩, it computes all configurations  |κ&#39;<em>up, κ&#39;</em>down⟩ that can be reached by applying H, along with their amplitudes.</p><p>The result is H|κ⟩ = Σ_κ&#39; xprime[κ&#39;] |κ&#39;⟩, where xprime encodes the expansion.</p><p><strong>Arguments</strong></p><ul><li><code>Ham::Hamiltonian</code>: Complete Hamiltonian specification</li><li><code>kappa_up::Vector{Int}</code>: Current up-spinon configuration</li><li><code>kappa_down::Vector{Int}</code>: Current down-spinon configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{NTuple{4,Int}, Float64}</code>: Dictionary mapping configurations to amplitudes<ul><li>Key (-1,-1,-1,-1): Diagonal contribution (Ising terms)</li><li>Key (i,l<em>up,j,l</em>down): Off-diagonal contribution from spin-flip at sites i,j</li></ul></li></ul><p><strong>Algorithm</strong></p><ol><li>Iterate over all nearest-neighbor bonds in Ham.nn</li><li>For each bond, compute Ising (S^z S^z) and transverse (S^+ S^- + S^- S^+) terms</li><li>Accumulate results in xprime dictionary</li></ol><p><strong>Usage in Monte Carlo</strong></p><ul><li>Called during each Monte Carlo update to propose new configurations</li><li>The amplitudes determine acceptance probabilities for updates</li><li>Essential for sampling the quantum mechanical evolution</li></ul><p><strong>Physics Notes</strong></p><ul><li>|x⟩ must be a valid Mott state (one spinon per site)</li><li>The Hamiltonian H is the original Heisenberg model, not the mean-field one</li><li>Combines both diagonal (Ising) and off-diagonal (transverse) contributions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L675-L711">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.init_conf_qr!-Tuple{MC, Int64, Int64}" href="#KagomeDSL.init_conf_qr!-Tuple{MC, Int64, Int64}"><code>KagomeDSL.init_conf_qr!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_conf_qr!(mc::MC, ns::Int, N_up::Int)</code></pre><p>Ref: Quantum Monte Carlo Approaches for Correlated Systems (Becca and Sorella, 2017) P130</p><p>As system size increases, <span>$&lt;Φ|x&gt;$</span> becomes exponentially small comparing to system size, inversely proportional to the dimension of the Hilbert space.</p><p>The smallness of init <span>$&lt;Φ|x&gt;$</span> will lead to numerical instability in the first computation of the W matrices, but not affecting the Markov chain sampling, since we always calculate <span>$\frac{&lt;Φ|x&#39;&gt;}{&lt;Φ|x&gt;}$</span> there, which shall not be a numerically instable number.</p><p>To avoid this issue we initializes the particle configurations <code>kappa_up</code> and <code>kappa_down</code> in the <code>mc</code> object using a deterministic method based on QR decomposition with column pivoting.</p><p>This approach is designed to select a set of sites for the up and down spin electrons that corresponds to a set of linearly independent rows from the <code>U_up</code> and <code>U_down</code> matrices, respectively. This maximizes the chances of producing a non-singular <code>tilde_U</code> matrix, avoiding the need for random trial-and-error.</p><p>The procedure is as follows:</p><ol><li>It performs QR decomposition on <code>mc.Ham.U_up&#39;</code> to select the <code>N_up</code> most  linearly independent rows (sites) for the up-spin electrons.</li><li>It then takes the remaining, unoccupied sites and performs a second QR  decomposition on the corresponding subset of <code>mc.Ham.U_down&#39;</code> to select the  <code>N_down</code> sites for the down-spin electrons.</li></ol><p>Parameters:</p><ul><li><code>mc</code>: The Monte Carlo object, which will be modified in-place.</li><li><code>ns</code>: The total number of sites in the lattice.</li><li><code>N_up</code>: The number of up-spin electrons.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L173-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}" href="#KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}"><code>KagomeDSL.is_occupied</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_occupied(kappa::Vector{Int}, l::Int) -&gt; Bool</code></pre><p>Check if site <code>l</code> is occupied in the kappa configuration vector.</p><p>Throws:     BoundsError: if l is outside the valid range of kappa</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.orbitals-Tuple{Matrix{ComplexF64}, Int64, Int64}" href="#KagomeDSL.orbitals-Tuple{Matrix{ComplexF64}, Int64, Int64}"><code>KagomeDSL.orbitals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orbitals(H_mat::Matrix{ComplexF64}, N_up::Int, N_down::Int) -&gt; (Matrix{ComplexF64}, Matrix{ComplexF64})</code></pre><p>Compute the occupied spinon orbitals for the quantum spin liquid ground state.</p><p>In the spinon mean-field theory:</p><ol><li>Spins are fractionalized into spinons (fermionic particles carrying spin-1/2)</li><li>The Hamiltonian H_mat describes spinon hopping on the lattice</li><li>Ground state is a filled Fermi sea of the lowest-energy spinon states</li><li>Separate up and down spinon sectors (SU(2) symmetry)</li></ol><p><strong>Arguments</strong></p><ul><li><code>H_mat::Matrix{ComplexF64}</code>: Single-particle spinon Hamiltonian matrix</li><li><code>N_up::Int</code>: Number of up-spin spinons to fill</li><li><code>N_down::Int</code>: Number of down-spin spinons to fill</li></ul><p><strong>Returns</strong></p><ul><li><code>(U_up, U_down)</code>: Matrices whose columns are the occupied spinon orbitals<ul><li><code>U_up</code>: N_up lowest eigenvectors for up spinons</li><li><code>U_down</code>: N_down lowest eigenvectors for down spinons</li></ul></li></ul><p><strong>Physics Notes</strong></p><ul><li>The spinon filling typically corresponds to the original spin-1/2 density</li><li>For a spin-1/2 system: N<em>up + N</em>down = total number of spins</li><li>The specific choice of N<em>up, N</em>down determines the magnetic properties</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L356-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}" href="#KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}"><code>KagomeDSL.spinInteraction!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spinInteraction!(xprime, kappa_up, kappa_down, i, j)</code></pre><p>Compute the transverse (spin-flip) part of the Heisenberg interaction.</p><p>For the Heisenberg Hamiltonian H = J ∑<em>{&lt;i,j&gt;} (S^+</em>i S^-<em>j + S^-</em>i S^+<em>j + S^z</em>i S^z<em>j), this function handles the transverse terms S^+</em>i S^-<em>j + S^-</em>i S^+_j.</p><p>In the spinon representation:</p><ul><li>S^+<em>i S^-</em>j = f^†<em>{i↑} f</em>{i↓} f^†<em>{j↓} f</em>{j↑} (flips spins at both sites)</li><li>S^-<em>i S^+</em>j = f^†<em>{i↓} f</em>{i↑} f^†<em>{j↑} f</em>{j↓} (flips spins at both sites)</li></ul><p>These terms change the spinon configuration and are the source of quantum fluctuations.</p><p><strong>Arguments</strong></p><ul><li><code>xprime::Dict</code>: Dictionary storing new configurations and their amplitudes</li><li><code>kappa_up::Vector{Int}</code>: Current up-spinon configuration</li><li><code>kappa_down::Vector{Int}</code>: Current down-spinon configuration</li><li><code>i::Int, j::Int</code>: Sites for the spin-flip interaction</li></ul><p><strong>Side Effects</strong></p><ul><li>Adds entries to xprime for each allowed spin-flip process</li><li>Key format: (new<em>up</em>site, old<em>up</em>orbital, new<em>down</em>site, old<em>down</em>orbital)</li><li>Amplitude: -1/2 for each allowed process (negative from Heisenberg coupling)</li></ul><p><strong>Physics Notes</strong></p><ul><li>Only processes that respect the constraint (one spinon per site) are allowed</li><li>Creates quantum entanglement between different spinon configurations</li><li>Essential for accessing quantum spin liquid physics beyond mean-field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L606-L636">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}" href="#KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}"><code>KagomeDSL.tilde_U</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tilde_U(U::AbstractMatrix, kappa::Vector{Int})</code></pre><hr/><p>Creates a tilde matrix by rearranging rows of U according to kappa indices.</p><p>Parameters:</p><ul><li><code>U</code>: Source matrix of size (n × m)</li><li><code>kappa</code>: Vector of indices where each non-zero value l indicates that row Rl of U         should be placed at row l of the output</li></ul><p>Returns:</p><ul><li>A matrix of size (m × m) with same element type as U</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L28-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.unitcell_coord-Tuple{KagomeDSL.AbstractLattice, Int64}" href="#KagomeDSL.unitcell_coord-Tuple{KagomeDSL.AbstractLattice, Int64}"><code>KagomeDSL.unitcell_coord</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitcell_coord(lat::AbstractLattice, s::Int) -&gt; Vector{Float64}</code></pre><p>Compute the real-space coordinate of the unit cell containing site <code>s</code>.</p><p>For DoubleKagome lattice:</p><ul><li>Sites 1-6 belong to unit cell 1, sites 7-12 to unit cell 2, etc.</li><li>Each unit cell has 6 sites arranged in two triangular motifs</li><li>Returns the coordinate of the unit cell origin in real space</li></ul><p><strong>Arguments</strong></p><ul><li><code>lat::AbstractLattice</code>: The lattice structure</li><li><code>s::Int</code>: Site index (1-indexed)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Real-space coordinate of the unit cell origin</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.unitcell_diff-Tuple{KagomeDSL.AbstractLattice, Vector{Float64}, Vector{Float64}}" href="#KagomeDSL.unitcell_diff-Tuple{KagomeDSL.AbstractLattice, Vector{Float64}, Vector{Float64}}"><code>KagomeDSL.unitcell_diff</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitcell_diff(lat, unitcell_coord1, unitcell_coord2) -&gt; (Int, Int)</code></pre><p>Calculate the lattice vector difference between two unit cells in terms of basis vectors (a1, a2).</p><p>This function solves the linear system: unitcell<em>coord1 - unitcell</em>coord2 = dx<em>a1 + dy</em>a2 to find integer coefficients (dx, dy) representing the separation in lattice units.</p><p><strong>Arguments</strong></p><ul><li><code>lat::AbstractLattice</code>: The lattice structure containing basis vectors a1, a2</li><li><code>unitcell_coord1::Vector{Float64}</code>: Real-space coordinate of first unit cell</li><li><code>unitcell_coord2::Vector{Float64}</code>: Real-space coordinate of second unit cell</li></ul><p><strong>Returns</strong></p><ul><li><code>(dx::Int, dy::Int)</code>: Lattice vector coefficients such that coord1 - coord2 = dx<em>a1 + dy</em>a2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/Hamiltonian.jl#L40-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.update_W!-Tuple{AbstractMatrix, Int64, Int64, AbstractVector, AbstractVector}" href="#KagomeDSL.update_W!-Tuple{AbstractMatrix, Int64, Int64, AbstractVector, AbstractVector}"><code>KagomeDSL.update_W!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_W!(W::AbstractMatrix; l::Int, K::Int)</code></pre><hr/><p>Update the W matrix <span>$W&#39;_{I,j} = W_{I,j} - W_{I,l} / W_{K,l} * (W_{K,j} - \delta_{l,j})$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.update_W_matrices!-Tuple{MC}" href="#KagomeDSL.update_W_matrices!-Tuple{MC}"><code>KagomeDSL.update_W_matrices!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_W_matrices(mc::MC; K_up::Int, K_down::Int, l_up::Int, l_down::Int)</code></pre><hr/><p>Update the W matrices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/e4d29d17436cfaa7a066078e5dfbe969eef386d1/src/MonteCarlo.jl#L141-L145">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« KagomeDSL</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 25 July 2025 03:46">Friday 25 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
