<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · KagomeDSL.jl</title><meta name="title" content="Reference · KagomeDSL.jl"/><meta property="og:title" content="Reference · KagomeDSL.jl"/><meta property="twitter:title" content="Reference · KagomeDSL.jl"/><meta name="description" content="Documentation for KagomeDSL.jl."/><meta property="og:description" content="Documentation for KagomeDSL.jl."/><meta property="twitter:description" content="Documentation for KagomeDSL.jl."/><meta property="og:url" content="https://hz-xiaxz.github.io/KagomeDSL.jl/95-reference/"/><meta property="twitter:url" content="https://hz-xiaxz.github.io/KagomeDSL.jl/95-reference/"/><link rel="canonical" href="https://hz-xiaxz.github.io/KagomeDSL.jl/95-reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">KagomeDSL.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">KagomeDSL</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/main/docs/src/95-reference.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="reference"><a class="docs-heading-anchor" href="#reference">Reference</a><a id="reference-1"></a><a class="docs-heading-anchor-permalink" href="#reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}"><code>KagomeDSL.DoubleKagome</code></a></li><li><a href="#KagomeDSL.Hamiltonian-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:KagomeDSL.AbstractLattice"><code>KagomeDSL.Hamiltonian</code></a></li><li><a href="#KagomeDSL.Hamiltonian"><code>KagomeDSL.Hamiltonian</code></a></li><li><a href="#KagomeDSL.MC-Tuple{AbstractDict}"><code>KagomeDSL.MC</code></a></li><li><a href="#KagomeDSL.MC"><code>KagomeDSL.MC</code></a></li><li><a href="#KagomeDSL.MC-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}, AbstractMatrix, AbstractMatrix}"><code>KagomeDSL.MC</code></a></li><li><a href="#Carlo.init!-Tuple{MC, MCContext, AbstractDict}"><code>Carlo.init!</code></a></li><li><a href="#Carlo.measure!-Tuple{MC, MCContext}"><code>Carlo.measure!</code></a></li><li><a href="#Carlo.read_checkpoint!-Tuple{MC, HDF5.Group}"><code>Carlo.read_checkpoint!</code></a></li><li><a href="#Carlo.register_evaluables-Tuple{Type{MC}, Carlo.Evaluator, AbstractDict}"><code>Carlo.register_evaluables</code></a></li><li><a href="#Carlo.sweep!-Tuple{MC, MCContext}"><code>Carlo.sweep!</code></a></li><li><a href="#Carlo.write_checkpoint-Tuple{MC, HDF5.Group}"><code>Carlo.write_checkpoint</code></a></li><li><a href="#KagomeDSL.Hmat-Tuple{DoubleKagome}"><code>KagomeDSL.Hmat</code></a></li><li><a href="#KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.Sz</code></a></li><li><a href="#KagomeDSL.SzInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}"><code>KagomeDSL.SzInteraction!</code></a></li><li><a href="#KagomeDSL.Z-Tuple{AbstractArray, AbstractVector, AbstractVector}"><code>KagomeDSL.Z</code></a></li><li><a href="#KagomeDSL.apply_boundary_conditions!-Tuple{AbstractMatrix, KagomeDSL.AbstractLattice, Int64, Int64, Dict, Float64}"><code>KagomeDSL.apply_boundary_conditions!</code></a></li><li><a href="#KagomeDSL.find_initial_configuration!-Tuple{MC, Int64, Int64}"><code>KagomeDSL.find_initial_configuration!</code></a></li><li><a href="#KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.getOL</code></a></li><li><a href="#KagomeDSL.get_boundary_shifts-Tuple{KagomeDSL.AbstractLattice, Int64, Int64}"><code>KagomeDSL.get_boundary_shifts</code></a></li><li><a href="#KagomeDSL.get_nn-Tuple{AbstractMatrix}"><code>KagomeDSL.get_nn</code></a></li><li><a href="#KagomeDSL.get_site_coord-Tuple{KagomeDSL.AbstractLattice, Int64}"><code>KagomeDSL.get_site_coord</code></a></li><li><a href="#KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.getxprime</code></a></li><li><a href="#KagomeDSL.init_conf_qr!-Tuple{MC, Int64, Int64}"><code>KagomeDSL.init_conf_qr!</code></a></li><li><a href="#KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}"><code>KagomeDSL.is_occupied</code></a></li><li><a href="#KagomeDSL.orbitals-Tuple{Matrix{ComplexF64}, Int64, Int64}"><code>KagomeDSL.orbitals</code></a></li><li><a href="#KagomeDSL.reevaluateW!-Tuple{MC}"><code>KagomeDSL.reevaluateW!</code></a></li><li><a href="#KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}"><code>KagomeDSL.spinInteraction!</code></a></li><li><a href="#KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}"><code>KagomeDSL.tilde_U</code></a></li><li><a href="#KagomeDSL.unitcell_coord-Tuple{KagomeDSL.AbstractLattice, Int64}"><code>KagomeDSL.unitcell_coord</code></a></li><li><a href="#KagomeDSL.unitcell_diff-Tuple{KagomeDSL.AbstractLattice, Vector{Float64}, Vector{Float64}}"><code>KagomeDSL.unitcell_diff</code></a></li><li><a href="#KagomeDSL.update_W!-Tuple{AbstractMatrix, Int64, Int64, AbstractVector, AbstractVector}"><code>KagomeDSL.update_W!</code></a></li><li><a href="#KagomeDSL.update_W_matrices!-Tuple{MC}"><code>KagomeDSL.update_W_matrices!</code></a></li><li><a href="#KagomeDSL.update_configurations!-Tuple{Any, Vararg{Int64, 5}}"><code>KagomeDSL.update_configurations!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}" href="#KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}"><code>KagomeDSL.DoubleKagome</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DoubleKagome(t::Float64, n1::Int, n2::Int, PBC::Tuple{Bool,Bool}; antiPBC=(false,false), trunc=Inf)</code></pre><p>Construct a double unit cell Kagome lattice with 6 sites per unit cell.</p><p>Unlike a single unit cell Kagome lattice (which has 3 sites per unit cell forming one triangle), the DoubleKagome lattice contains 6 sites per unit cell arranged in two triangular sublattices. This structure is useful for studying systems with enlarged unit cells or specific magnetic ordering patterns that require the doubled cell geometry.</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Parameter defining the equilateral triangle side length (lattice constant = 2t)</li><li><code>n1::Int</code>: Number of unit cell repetitions in the a1 direction (must be even)</li><li><code>n2::Int</code>: Number of unit cell repetitions in the a2 direction  </li><li><code>PBC::Tuple{Bool,Bool}</code>: Periodic boundary conditions in (a1, a2) directions</li><li><code>antiPBC::Tuple{Bool,Bool}</code>: Antiperiodic boundary conditions (default: (false, false))</li><li><code>trunc::Float64</code>: Truncation parameter (default: Inf, unused in current implementation)</li></ul><p><strong>Returns</strong></p><ul><li><code>DoubleKagome</code>: Lattice structure with <code>n1 * n2 * 3</code> total sites</li></ul><p><strong>Notes</strong></p><ul><li>The constraint <code>n1 % 2 == 0</code> ensures proper tiling of the double unit cell</li><li>Total number of sites is <code>n1 * n2 * 3</code> (though each unit cell has 6 sites, <code>n1</code> counts double-sized cells)</li><li>Actual number of unit cells is <code>(n1 ÷ 2) * n2</code>, each containing 6 sites</li><li>Lattice vectors: a1 = [4t, 0], a2 = [t, √3*t] </li><li>Each unit cell contains 6 sites arranged in two triangular motifs</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a 4×3 DoubleKagome lattice with periodic boundaries
lat = DoubleKagome(1.0, 4, 3, (true, true))
# Total sites: 4 * 3 * 3 = 36 sites (2 unit cells × 3 repetitions × 6 sites per unit cell)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Lattice.jl#L33-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.Hamiltonian" href="#KagomeDSL.Hamiltonian"><code>KagomeDSL.Hamiltonian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hamiltonian</code></pre><p>Complete specification of the spinon mean-field Hamiltonian for quantum Monte Carlo simulations.</p><p>This structure contains all information needed for Variational  Monte Carlo calculations of quantum spin liquid properties:</p><p><strong>Fields</strong></p><ul><li><code>N_up::Int</code>: Number of up-spin spinons (determines spin sector)</li><li><code>N_down::Int</code>: Number of down-spin spinons</li><li><code>U_up::Matrix{ComplexF64}</code>: Occupied up-spinon orbitals (columns are eigenvectors)</li><li><code>U_down::Matrix{ComplexF64}</code>: Occupied down-spinon orbitals</li><li><code>H_mat::Matrix{ComplexF64}</code>: Single-particle spinon Hamiltonian matrix</li><li><code>nn::AbstractArray</code>: List of nearest-neighbor bonds for efficient iteration</li></ul><p><strong>Usage in Monte Carlo</strong></p><ul><li>U<em>up, U</em>down define the reference state (filled Fermi sea)</li><li>H_mat provides the hopping amplitudes for Monte Carlo updates</li><li>nn specifies which bonds to consider in interaction terms</li></ul><p><strong>Physical Interpretation</strong></p><ul><li>Represents a quantum spin liquid state where spins are fractionalized</li><li>Correlations arise from quantum fluctuations around the mean-field state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L395-L420">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.Hamiltonian-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:KagomeDSL.AbstractLattice" href="#KagomeDSL.Hamiltonian-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:KagomeDSL.AbstractLattice"><code>KagomeDSL.Hamiltonian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hamiltonian(N_up, N_down, lat; link_in=pi_link_in, link_inter=pi_link_inter, B=0.0)</code></pre><p>Construct a complete Hamiltonian structure for quantum Monte Carlo simulations.</p><p>This is the main constructor that builds everything needed for SSE Monte Carlo:</p><ol><li>Constructs the single-particle spinon Hamiltonian matrix</li><li>Diagonalizes it to find the occupied orbitals</li><li>Extracts the nearest-neighbor bond structure</li><li>Packages everything for efficient Monte Carlo usage</li></ol><p><strong>Arguments</strong></p><ul><li><code>N_up::Int, N_down::Int</code>: Number of up/down spinons (determines magnetic sector)</li><li><code>lat::AbstractLattice</code>: Lattice structure (typically DoubleKagome)</li><li><code>link_in</code>: Intra-cell hopping dictionary (default: π-flux pattern)</li><li><code>link_inter</code>: Inter-cell hopping dictionary (default: π-flux pattern)</li><li><code>B::Float64</code>: Magnetic field strength for Peierls phases (default: 0.0)</li></ul><p><strong>Returns</strong></p><ul><li><code>Hamiltonian</code>: Complete structure ready for Monte Carlo simulations</li></ul><p><strong>Physics Notes</strong></p><ul><li>The choice of N<em>up, N</em>down determines the spin sector being studied</li><li>For spin-1/2 systems: N<em>up + N</em>down = number of original spins</li><li>Different (N<em>up, N</em>down) can access different quantum phases</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L454-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.MC" href="#KagomeDSL.MC"><code>KagomeDSL.MC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MC &lt;: AbstractMC</code></pre><p>Monte Carlo simulation state for quantum spin systems on the Kagome lattice.</p><p><strong>Fields</strong></p><ul><li><code>Ham::Hamiltonian</code>: The Hamiltonian describing the physical system</li><li><code>kappa_up::Vector{Int}</code>: Configuration vector for up-spin electrons</li><li><code>kappa_down::Vector{Int}</code>: Configuration vector for down-spin electrons  </li><li><code>W_up::AbstractMatrix</code>: One-particle Green&#39;s function matrix for up-spin electrons</li><li><code>W_down::AbstractMatrix</code>: One-particle Green&#39;s function matrix for down-spin electrons</li><li><code>W_up_col_cache::AbstractVector</code>: Cache vector for column operations on W_up</li><li><code>W_up_row_cache::AbstractVector</code>: Cache vector for row operations on W_up</li><li><code>W_down_col_cache::AbstractVector</code>: Cache vector for column operations on W_down</li><li><code>W_down_row_cache::AbstractVector</code>: Cache vector for row operations on W_down</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.MC-Tuple{AbstractDict}" href="#KagomeDSL.MC-Tuple{AbstractDict}"><code>KagomeDSL.MC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MC(params::AbstractDict)</code></pre><p>Create a Monte Carlo object from a dictionary of parameters.</p><p>This is the user-facing, high-level constructor that initializes the Monte Carlo simulation state with appropriate dimensions and default configurations.</p><p><strong>Arguments</strong></p><ul><li><code>params::AbstractDict</code>: Dictionary containing simulation parameters</li></ul><p><strong>Required Parameters</strong></p><ul><li><code>:n1::Int</code>: Number of unit cells in x-direction</li><li><code>:n2::Int</code>: Number of unit cells in y-direction  </li><li><code>:PBC::Tuple{Bool,2}</code>: Periodic boundary conditions</li><li><code>:N_up::Int</code>: Number of up-spin electrons</li><li><code>:N_down::Int</code>: Number of down-spin electrons</li></ul><p><strong>Optional Parameters</strong></p><ul><li><code>:antiPBC::Tuple{Bool,2}</code>: Anti-periodic boundary conditions (default: (false, false))</li><li><code>:lattice::Type</code>: Lattice type (default: DoubleKagome)</li><li><code>:B::Float64</code>: Magnetic field strength (default: 0.0)</li><li><code>:link_in::Function</code>: Intra-cell linking function (default: pi<em>link</em>in)</li><li><code>:link_inter::Function</code>: Inter-cell linking function (default: pi<em>link</em>inter)</li></ul><p><strong>Returns</strong></p><ul><li><code>MC</code>: Initialized Monte Carlo state object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L137-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.MC-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}, AbstractMatrix, AbstractMatrix}" href="#KagomeDSL.MC-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}, AbstractMatrix, AbstractMatrix}"><code>KagomeDSL.MC</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MC(Ham, kappa_up, kappa_down, W_up, W_down)</code></pre><p>Create a Monte Carlo object from its core components.</p><p>This constructor automatically creates the necessary cache arrays for efficient matrix updates. It&#39;s primarily used for internal logic and testing purposes.</p><p><strong>Arguments</strong></p><ul><li><code>Ham::Hamiltonian</code>: The Hamiltonian describing the physical system</li><li><code>kappa_up::Vector{Int}</code>: Initial up-spin configuration vector</li><li><code>kappa_down::Vector{Int}</code>: Initial down-spin configuration vector</li><li><code>W_up::AbstractMatrix</code>: Initial one-particle Green&#39;s function for up-spin</li><li><code>W_down::AbstractMatrix</code>: Initial one-particle Green&#39;s function for down-spin</li></ul><p><strong>Returns</strong></p><ul><li><code>MC</code>: Monte Carlo state object with initialized cache arrays</li></ul><p><strong>Note</strong></p><p>The cache arrays enable zero-allocation updates of the Green&#39;s function matrices using rank-1 update operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L187-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.init!-Tuple{MC, MCContext, AbstractDict}" href="#Carlo.init!-Tuple{MC, MCContext, AbstractDict}"><code>Carlo.init!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.init!(mc::MC, ctx::MCContext, params::AbstractDict)</code></pre><p>Initialize the Monte Carlo object for Carlo.jl framework integration.</p><p>This function sets up the Monte Carlo simulation by finding an initial non-singular configuration using QR-based initialization.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo state object</li><li><code>ctx::MCContext</code>: Carlo.jl context object</li><li><code>params::AbstractDict</code>: Simulation parameters dictionary</li></ul><p><strong>Parameters Used</strong></p><ul><li><code>:n1::Int</code>: Number of unit cells in x-direction</li><li><code>:n2::Int</code>: Number of unit cells in y-direction</li><li><code>:N_up::Int</code>: Number of up-spin electrons</li></ul><p><strong>Note</strong></p><p>This function integrates with the Carlo.jl framework and is called automatically during simulation initialization to prepare the Monte Carlo state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L413-L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.measure!-Tuple{MC, MCContext}" href="#Carlo.measure!-Tuple{MC, MCContext}"><code>Carlo.measure!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@inline function Carlo.measure!(mc::MC, ctx::MCContext)</code></pre><p>Measures observables during the simulation and collects data.</p><p>This function is called periodically during the simulation to measure physical observables like local energy and collect them for postprocessing.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo state object</li><li><code>ctx::MCContext</code>: Carlo.jl context object</li></ul><p><strong>Measured Quantities</strong></p><ul><li><code>:OL</code>: Local energy estimator <code>getOL(mc, mc.kappa_up, mc.kappa_down)</code></li></ul><p><strong>Note</strong></p><p>Measurements are taken periodically (every n_occupied sweeps) to reduce correlation between samples and improve measurement efficiency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L609-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.read_checkpoint!-Tuple{MC, HDF5.Group}" href="#Carlo.read_checkpoint!-Tuple{MC, HDF5.Group}"><code>Carlo.read_checkpoint!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.read_checkpoint!(mc::MC, in::HDF5.Group)</code></pre><p>Restore Monte Carlo state from saved checkpoint for simulation continuation.</p><p><strong>Purpose</strong>: Loads previously saved spin configurations to resume a simulation from a specific state or initialize postprocessing analysis.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo object to restore (modified in-place)</li><li><code>in::HDF5.Group</code>: Input HDF5 group containing checkpoint data</li></ul><p><strong>Restored Data</strong></p><ul><li><code>kappa_up</code>: Up-spin configuration vector</li><li><code>kappa_down</code>: Down-spin configuration vector</li></ul><p><strong>Usage Contexts</strong></p><ol><li><strong>Simulation resumption</strong>: Continue interrupted long simulations</li><li><strong>Postprocessing initialization</strong>: Start analysis from specific configurations</li><li><strong>Reproducibility</strong>: Restore exact simulation states</li></ol><p><strong>Side Effects</strong></p><ul><li>Modifies <code>mc.kappa_up</code> and <code>mc.kappa_down</code> in-place</li><li>Overwrites current Monte Carlo configuration completely</li></ul><p><strong>Notes</strong></p><ul><li>Called automatically by Carlo.jl when resuming from checkpoints</li><li>Essential for maintaining simulation continuity</li><li>Enables reproducible analysis workflows</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L721-L750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.register_evaluables-Tuple{Type{MC}, Carlo.Evaluator, AbstractDict}" href="#Carlo.register_evaluables-Tuple{Type{MC}, Carlo.Evaluator, AbstractDict}"><code>Carlo.register_evaluables</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.register_evaluables(::Type{MC}, eval::Evaluator, params::AbstractDict)</code></pre><p>Register postprocessing evaluators for final analysis after Monte Carlo simulation.</p><p><strong>IMPORTANT: This is purely for postprocessing</strong> - these evaluators are executed  at the end of the simulation or during merge operations to compute final observables  from the collected raw measurements. They do NOT affect the Monte Carlo dynamics.</p><p>This function defines how to compute physical observables from the raw measured  data (:OL values) that was collected during the simulation via Carlo.measure!().</p><p><strong>Arguments</strong></p><ul><li><code>::Type{MC}</code>: Monte Carlo type dispatch</li><li><code>eval::Evaluator</code>: Carlo.jl evaluator for postprocessing computations</li><li><code>params::AbstractDict</code>: Simulation parameters containing lattice dimensions</li></ul><p><strong>Registered Evaluables</strong></p><ul><li><code>:energy</code>: Computes the energy per site from local energy measurements<ul><li>Formula: <span>$energy = ⟨OL⟩ / ns$</span>, where ns = total number of sites</li><li>Input: Raw :OL measurements collected during simulation</li><li>Output: Normalized energy per site for final results</li></ul></li></ul><p><strong>Usage in Carlo.jl Workflow</strong></p><ol><li><strong>During simulation</strong>: <code>Carlo.measure!()</code> collects raw <code>:OL</code> data</li><li><strong>After simulation</strong>: This function defines how to postprocess the data</li><li><strong>Final analysis</strong>: Carlo.jl automatically applies these evaluators to compute final results</li><li><strong>Merge operations</strong>: Used when combining data from multiple simulation runs</li></ol><p><strong>Physics Notes</strong></p><ul><li><code>OL</code> represents the local energy estimator <span>$⟨x|H|ψ_G⟩/⟨x|ψ_G⟩$</span></li><li>Normalization by <code>ns</code> gives energy per site (intensive quantity)</li><li>Essential for comparing results across different system sizes</li></ul><p><strong>Performance Notes</strong></p><ul><li>Called only once during setup, not during simulation loops</li><li>Actual evaluation happens in postprocessing phase</li><li>Minimal computational overhead during Monte Carlo sampling</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L636-L674">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.sweep!-Tuple{MC, MCContext}" href="#Carlo.sweep!-Tuple{MC, MCContext}"><code>Carlo.sweep!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.sweep!(mc::MC, ctx::MCContext) -&gt; Nothing</code></pre><p>Perform one Monte Carlo sweep for Mott state simulation.</p><p>This function implements a two-spin swap update where electrons can exchange positions between different spin states at occupied neighboring sites.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo state object</li><li><code>ctx::MCContext</code>: Carlo.jl context object</li></ul><p><strong>Algorithm</strong></p><ol><li>Calculate number of valid spin exchange moves Zμ</li><li>Use Metropolis acceptance criterion based on move probability</li><li>Select random neighbor bond for potential exchange</li><li>Calculate acceptance ratio using Green&#39;s function matrix elements</li><li>Update configurations if move is accepted</li><li>Periodically re-evaluate W matrices to maintain numerical stability</li></ol><p><strong>Note</strong></p><p>The W matrices are re-evaluated periodically (every n_occupied sweeps) to override numerical instability from repeated rank-1 updates. If re-evaluation fails due to singular matrices, a warning is issued and simulation continues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L513-L537">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Carlo.write_checkpoint-Tuple{MC, HDF5.Group}" href="#Carlo.write_checkpoint-Tuple{MC, HDF5.Group}"><code>Carlo.write_checkpoint</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Carlo.write_checkpoint(mc::MC, out::HDF5.Group)</code></pre><p>Save Monte Carlo state for resuming simulations or postprocessing analysis.</p><p><strong>Purpose</strong>: Serializes the current spin configuration to an HDF5 file for later use in simulation continuation or postprocessing workflows.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo state to save</li><li><code>out::HDF5.Group</code>: Output HDF5 group for writing checkpoint data</li></ul><p><strong>Saved Data</strong></p><ul><li><code>kappa_up</code>: Current up-spin configuration vector</li><li><code>kappa_down</code>: Current down-spin configuration vector</li></ul><p><strong>Usage Contexts</strong></p><ol><li><strong>Simulation checkpointing</strong>: Save state for restarting long simulations</li><li><strong>Postprocessing</strong>: Preserve final configurations for additional analysis</li><li><strong>Data archival</strong>: Store representative configurations for later study</li></ol><p><strong>Notes</strong></p><ul><li>Called automatically by Carlo.jl during simulation checkpointing</li><li>Essential for resuming interrupted simulations</li><li>Enables analysis of specific configurations post-simulation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L689-L714">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.Hmat-Tuple{DoubleKagome}" href="#KagomeDSL.Hmat-Tuple{DoubleKagome}"><code>KagomeDSL.Hmat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hmat(
    lat::DoubleKagome;
    link_in = pi_link_in,
    link_inter = pi_link_inter,
    B = 0.0,
) -&gt; Matrix{ComplexF64}</code></pre><p>Constructs the Spinon Hamiltonian matrix for a <code>DoubleKagome</code> lattice.</p><p>This function calculates the hopping terms within and between unit cells, incorporating a Peierls phase to account for a magnetic field <code>B</code>. The resulting matrix represents the Hamiltonian of the system.</p><p><strong>Arguments</strong></p><ul><li><code>lat::DoubleKagome</code>: The lattice structure for which to construct the Hamiltonian.</li><li><code>link_in</code>: A dictionary defining in-cell hopping terms. Defaults to <code>pi_link_in</code>.</li><li><code>link_inter</code>: A dictionary defining inter-cell hopping terms. Defaults to <code>pi_link_inter</code>.</li><li><code>B::Float64</code>: The magnetic field strength, used to calculate the Peierls phase. Defaults to <code>0.0</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{ComplexF64}</code>: The Hamiltonian matrix for the given lattice and parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L285-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}" href="#KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.Sz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sz(i::Int, kappa_up::Vector{Int}, kappa_down::Vector{Int}) -&gt; Float64</code></pre><p>Calculate the z-component of spin at site <code>i</code> in the spinon representation.</p><p>In the spinon formulation, the original spin operators are written as:</p><ul><li>S^z<em>i = 1/2 (f^†</em>{i↑} f<em>{i↑} - f^†</em>{i↓} f_{i↓})</li><li>S^+<em>i = f^†</em>{i↑} f<em>{i↓}, S^-</em>i = f^†<em>{i↓} f</em>{i↑}</li></ul><p>where f<em>{iσ} are spinon annihilation operators. The constraint is exactly one  spinon per site: n</em>{i↑} + n_{i↓} = 1 (no double occupancy or empty sites).</p><p><strong>Arguments</strong></p><ul><li><code>i::Int</code>: Site index (1-indexed)</li><li><code>kappa_up::Vector{Int}</code>: Up-spinon configuration (0 = empty, nonzero = occupied)</li><li><code>kappa_down::Vector{Int}</code>: Down-spinon configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: +0.5 for up spin, -0.5 for down spin</li></ul><p><strong>Exceptions</strong></p><ul><li><code>ArgumentError</code>: If site is doubly occupied or empty (violates spinon constraint)</li><li><code>BoundsError</code>: If i is outside valid range [1, length(kappa_up)]</li><li><code>DimensionMismatch</code>: If kappa<em>up and kappa</em>down have different lengths</li></ul><p><strong>Physics Notes</strong></p><ul><li>This enforces the constraint that each site has exactly one spinon</li><li>Configurations violating the constraint (empty or doubly occupied) are unphysical</li><li>Used in Monte Carlo to measure local magnetization and Ising interactions</li><li>The spinon constraint is fundamental to the validity of the spin liquid state</li></ul><p><strong>Performance Notes</strong></p><ul><li>Marked @inline for performance in Monte Carlo loops</li><li>Uses @boundscheck for optional bounds checking</li><li>Calls is_occupied() helper function for spinon occupancy detection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L495-L531">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.SzInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}" href="#KagomeDSL.SzInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}"><code>KagomeDSL.SzInteraction!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SzInteraction!(xprime, kappa_up, kappa_down, i, j)</code></pre><p>Compute the Ising (S^z S^z) interaction term for the Heisenberg Hamiltonian.</p><p>For the Heisenberg model H = J ∑<em>{&lt;i,j&gt;} (S^+</em>i S^-<em>j + S^-</em>i S^+<em>j + S^z</em>i S^z<em>j), this function handles the S^z</em>i S^z_j term, which is diagonal in the spinon basis.</p><p>The Ising term doesn&#39;t change the spinon configuration, so it contributes to the identity component of the operator expansion (stored with key (-1,-1,-1,-1)).</p><p><strong>Arguments</strong></p><ul><li><code>xprime::Dict</code>: Dictionary storing operator expansion coefficients</li><li><code>kappa_up::Vector{Int}</code>: Current up-spinon configuration</li><li><code>kappa_down::Vector{Int}</code>: Current down-spinon configuration  </li><li><code>i::Int, j::Int</code>: Sites for the interaction</li></ul><p><strong>Side Effects</strong></p><ul><li>Modifies xprime[(-1,-1,-1,-1)] by adding Sz(i) * Sz(j)</li></ul><p><strong>Physics Notes</strong></p><ul><li>This is the &quot;easy-axis&quot; part of the Heisenberg interaction</li><li>Diagonal in the occupation basis, doesn&#39;t create/destroy spinons</li><li>Combined with spinInteraction!() to give the full Heisenberg model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L568-L593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.Z-Tuple{AbstractArray, AbstractVector, AbstractVector}" href="#KagomeDSL.Z-Tuple{AbstractArray, AbstractVector, AbstractVector}"><code>KagomeDSL.Z</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Z(nn::AbstractArray, kappa_up::AbstractVector, kappa_down::AbstractVector) -&gt; Int</code></pre><p>Count the number of valid spin exchange moves between neighboring sites.</p><p>This function calculates the number of neighboring site pairs where one site is occupied by an up-spin electron and the other by a down-spin electron, indicating potential spin exchange moves.</p><p><strong>Arguments</strong></p><ul><li><code>nn::AbstractArray</code>: Array of neighbor bonds (site pairs)</li><li><code>kappa_up::AbstractVector</code>: Up-spin configuration vector</li><li><code>kappa_down::AbstractVector</code>: Down-spin configuration vector</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Number of valid spin exchange move opportunities</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L443-L459">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.apply_boundary_conditions!-Tuple{AbstractMatrix, KagomeDSL.AbstractLattice, Int64, Int64, Dict, Float64}" href="#KagomeDSL.apply_boundary_conditions!-Tuple{AbstractMatrix, KagomeDSL.AbstractLattice, Int64, Int64, Dict, Float64}"><code>KagomeDSL.apply_boundary_conditions!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply_boundary_conditions!(tunneling, lat, s1, s2, link_inter, B)</code></pre><p>Apply boundary conditions and magnetic field effects to inter-cell hopping terms.</p><p>This function modifies the tunneling matrix by adding all possible hopping paths  between sites s1 and s2, considering:</p><ol><li>Periodic/antiperiodic boundary conditions</li><li>Peierls phase factors from magnetic field B</li><li>π-flux pattern encoded in link_inter dictionary</li></ol><p><strong>Arguments</strong></p><ul><li><code>tunneling::AbstractMatrix</code>: Hopping matrix to be modified (in-place)</li><li><code>lat::AbstractLattice</code>: Lattice structure with boundary conditions</li><li><code>s1::Int, s2::Int</code>: Source and target site indices</li><li><code>link_inter::Dict</code>: Inter-cell hopping amplitudes with (label1, label2, dx, dy) keys</li><li><code>B::Float64</code>: Magnetic field strength for Peierls phase calculation</li></ul><p><strong>Physics Details</strong></p><ul><li>Peierls phase: exp(iB/2 * (x1+x2)(y2-y1)) accounts for vector potential A = (0, Bx)</li><li>Each boundary crossing can contribute ±1 phase factor from antiperiodic BC</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L155-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.find_initial_configuration!-Tuple{MC, Int64, Int64}" href="#KagomeDSL.find_initial_configuration!-Tuple{MC, Int64, Int64}"><code>KagomeDSL.find_initial_configuration!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_initial_configuration!(mc::MC, ns::Int, N_up::Int)</code></pre><p>Find a non-singular initial configuration for Monte Carlo simulation.</p><p>This function uses a deterministic QR-based method to initialize particle configurations and compute the initial Green&#39;s function matrices.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo state object (modified in-place)</li><li><code>ns::Int</code>: Total number of sites in the lattice</li><li><code>N_up::Int</code>: Number of up-spin electrons</li></ul><p><strong>Algorithm</strong></p><ol><li>Initialize configurations using QR decomposition with column pivoting</li><li>Construct tilde_U matrices from the initialized configurations</li><li>Solve linear systems to compute Green&#39;s function matrices</li><li>Handle singular matrix exceptions with informative error messages</li></ol><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If QR-based configuration produces singular matrices, indicating potential rank deficiency in the Hamiltonian</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L359-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}" href="#KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.getOL</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getOL(mc::AbstractMC, kappa_up, kappa_down) -&gt; Float64</code></pre><p>Compute the local energy estimator for quantum Monte Carlo.</p><p>Calculates the observable O<em>L = ⟨x|H|ψ</em>G⟩/⟨x|ψ_G⟩, which provides an unbiased estimator of the ground state energy in the Stochastic Series Expansion method.</p><p>In the spinon mean-field framework:</p><ul><li>|ψ_G⟩ is the Slater Determinant spinon state (Gutzwiller projected)</li><li>|x⟩ = |κ<em>up⟩ ⊗ |κ</em>down⟩ is a particular spinon configuration</li><li>H is the original Heisenberg Hamiltonian (not the mean-field one!)</li></ul><p>The ratio gives the local contribution to the energy from configuration |x⟩.</p><p><strong>Arguments</strong></p><ul><li><code>mc::AbstractMC</code>: Monte Carlo state containing W<em>up, W</em>down matrices</li><li><code>kappa_up::Vector{Int}</code>: Current up-spinon configuration</li><li><code>kappa_down::Vector{Int}</code>: Current down-spinon configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Local energy contribution from this configuration</li></ul><p><strong>Algorithm</strong></p><ol><li>Compute H|x⟩ using getxprime() to get all reachable configurations</li><li>For diagonal terms: directly add the Ising contributions</li><li>For off-diagonal terms: weight by the wavefunction amplitude ratios W<em>up, W</em>down</li><li>Sum all contributions to get the local energy</li></ol><p><strong>Physics Notes</strong></p><ul><li>This is the &quot;local energy&quot; in variational Monte Carlo terminology</li><li>Fluctuations in O_L reflect the quality of the trial wavefunction</li><li>Used to measure energy and other observables in quantum spin liquids</li><li>The Hamiltonian H must be the original physical one, not the mean-field approximation</li></ul><p><strong>Performance Notes</strong></p><ul><li>Critical function called in every Monte Carlo step</li><li>Bounds checking disabled with @inbounds for performance</li><li>Uses efficient iteration over pairs() for dictionary access</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L722-L762">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.get_boundary_shifts-Tuple{KagomeDSL.AbstractLattice, Int64, Int64}" href="#KagomeDSL.get_boundary_shifts-Tuple{KagomeDSL.AbstractLattice, Int64, Int64}"><code>KagomeDSL.get_boundary_shifts</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_boundary_shifts(lat::AbstractLattice, s1::Int, s2::Int) -&gt; Vector{Tuple{Int,Int,Float64}}</code></pre><p>Calculate all possible lattice vector shifts between sites s1 and s2 under periodic/antiperiodic boundary conditions.</p><p>For quantum spin systems with twisted boundary conditions:</p><ul><li>Periodic BC: ψ(r + L) = ψ(r)</li><li>Antiperiodic BC: ψ(r + L) = -ψ(r)</li></ul><p>Returns all equivalent separations considering lattice periodicity, with associated phase factors.</p><p><strong>Arguments</strong></p><ul><li><code>lat::AbstractLattice</code>: Lattice with boundary condition specifications</li><li><code>s1::Int, s2::Int</code>: Site indices for the hopping term</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{Int,Int,Float64}}</code>: List of (dx, dy, sign) tuples where:<ul><li><code>dx, dy</code>: Lattice vector coefficients</li><li><code>sign</code>: Phase factor (±1) from antiperiodic boundary crossings</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L79-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.get_nn-Tuple{AbstractMatrix}" href="#KagomeDSL.get_nn-Tuple{AbstractMatrix}"><code>KagomeDSL.get_nn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nn(H_mat::AbstractMatrix) -&gt; Vector{Tuple{Int,Int}}</code></pre><p>Extract nearest-neighbor bond list from the Hamiltonian matrix.</p><p>Finds all non-zero off-diagonal elements in the upper triangular part of H_mat, which correspond to hopping terms between connected sites. Essential for efficient Monte Carlo sampling since we only need to consider active bonds.</p><p><strong>Arguments</strong></p><ul><li><code>H_mat::AbstractMatrix</code>: Hamiltonian matrix (typically hermitian)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{Int,Int}}</code>: List of (i,j) pairs where i &lt; j and H_mat[i,j] ≠ 0</li></ul><p><strong>Notes</strong></p><ul><li>Only upper triangular elements to avoid double-counting</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L429-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.get_site_coord-Tuple{KagomeDSL.AbstractLattice, Int64}" href="#KagomeDSL.get_site_coord-Tuple{KagomeDSL.AbstractLattice, Int64}"><code>KagomeDSL.get_site_coord</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_site_coord(lat::AbstractLattice, s::Int) -&gt; Vector{Float64}</code></pre><p>Calculate the real-space coordinate of site <code>s</code> in the lattice.</p><p>Combines the unit cell position with the intra-cell site offset to give the absolute position in real space. Essential for calculating Peierls phases and analyzing spatial correlations.</p><p><strong>Arguments</strong></p><ul><li><code>lat::AbstractLattice</code>: Lattice structure</li><li><code>s::Int</code>: Site index (1-indexed)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: [x, y] coordinate in real space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L263-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}" href="#KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}"><code>KagomeDSL.getxprime</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getxprime(Ham::Hamiltonian, kappa_up, kappa_down) -&gt; Dict{NTuple{4,Int}, Float64}</code></pre><p>Compute the action of the Heisenberg Hamiltonian on a spinon configuration.</p><p>This is the core function for Stochastic Series Expansion (SSE) Monte Carlo. Given a spinon configuration |κ<em>up, κ</em>down⟩, it computes all configurations  |κ&#39;<em>up, κ&#39;</em>down⟩ that can be reached by applying H, along with their amplitudes.</p><p>The result is H|κ⟩ = Σ_κ&#39; xprime[κ&#39;] |κ&#39;⟩, where xprime encodes the expansion.</p><p><strong>Arguments</strong></p><ul><li><code>Ham::Hamiltonian</code>: Complete Hamiltonian specification</li><li><code>kappa_up::Vector{Int}</code>: Current up-spinon configuration</li><li><code>kappa_down::Vector{Int}</code>: Current down-spinon configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{NTuple{4,Int}, Float64}</code>: Dictionary mapping configurations to amplitudes<ul><li>Key (-1,-1,-1,-1): Diagonal contribution (Ising terms)</li><li>Key (i,l<em>up,j,l</em>down): Off-diagonal contribution from spin-flip at sites i,j</li></ul></li></ul><p><strong>Algorithm</strong></p><ol><li>Iterate over all nearest-neighbor bonds in Ham.nn</li><li>For each bond, compute Ising (S^z S^z) and transverse (S^+ S^- + S^- S^+) terms</li><li>Accumulate results in xprime dictionary</li></ol><p><strong>Usage in Monte Carlo</strong></p><ul><li>Called during each Monte Carlo update to propose new configurations</li><li>The amplitudes determine acceptance probabilities for updates</li><li>Essential for sampling the quantum mechanical evolution</li></ul><p><strong>Physics Notes</strong></p><ul><li>|x⟩ must be a valid Mott state (one spinon per site)</li><li>The Hamiltonian H is the original Heisenberg model, not the mean-field one</li><li>Combines both diagonal (Ising) and off-diagonal (transverse) contributions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L675-L711">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.init_conf_qr!-Tuple{MC, Int64, Int64}" href="#KagomeDSL.init_conf_qr!-Tuple{MC, Int64, Int64}"><code>KagomeDSL.init_conf_qr!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_conf_qr!(mc::MC, ns::Int, N_up::Int)</code></pre><p>Initialize particle configurations using QR decomposition with column pivoting.</p><p>Reference: Quantum Monte Carlo Approaches for Correlated Systems (Becca and Sorella, 2017) P130</p><p>As system size increases, <span>$⟨Φ|x⟩$</span> becomes exponentially small compared to system size, inversely proportional to the dimension of the Hilbert space.</p><p>The smallness of initial <span>$⟨Φ|x⟩$</span> leads to numerical instability in the first computation of the W matrices, but does not affect Markov chain sampling since we always calculate <span>$⟨Φ|x&#39;⟩/⟨Φ|x⟩$</span>, which should not be numerically unstable.</p><p>This method selects sites that maximize linear independence from the U matrices to ensure non-singular tilde_U matrices and avoid random trial-and-error initialization.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo state object (modified in-place)</li><li><code>ns::Int</code>: Total number of sites in the lattice</li><li><code>N_up::Int</code>: Number of up-spin electrons</li></ul><p><strong>Algorithm</strong></p><ol><li>Perform QR decomposition on <code>mc.Ham.U_up&#39;</code> to select <code>N_up</code> most linearly independent rows (sites) for up-spin electrons</li><li>Use remaining unoccupied sites and perform QR decomposition on corresponding subset of <code>mc.Ham.U_down&#39;</code> to select <code>N_down</code> sites for down-spin electrons</li></ol><p><strong>Note</strong></p><p>This deterministic approach produces non-singular tilde_U matrices for stable Green&#39;s function initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L295-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}" href="#KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}"><code>KagomeDSL.is_occupied</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_occupied(kappa::Vector{Int}, l::Int) -&gt; Bool</code></pre><p>Check if site <code>l</code> is occupied in the configuration vector.</p><p><strong>Arguments</strong></p><ul><li><code>kappa::Vector{Int}</code>: Configuration vector where non-zero values indicate occupation</li><li><code>l::Int</code>: Site index to check</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: true if site l is occupied (kappa[l] ≠ 0), false otherwise</li></ul><p><strong>Throws</strong></p><ul><li><code>BoundsError</code>: if l is outside the valid range [1, length(kappa)]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L117-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.orbitals-Tuple{Matrix{ComplexF64}, Int64, Int64}" href="#KagomeDSL.orbitals-Tuple{Matrix{ComplexF64}, Int64, Int64}"><code>KagomeDSL.orbitals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">orbitals(H_mat::Matrix{ComplexF64}, N_up::Int, N_down::Int) -&gt; (Matrix{ComplexF64}, Matrix{ComplexF64})</code></pre><p>Compute the occupied spinon orbitals for the quantum spin liquid ground state.</p><p>In the spinon mean-field theory:</p><ol><li>Spins are fractionalized into spinons (fermionic particles carrying spin-1/2)</li><li>The Hamiltonian H_mat describes spinon hopping on the lattice</li><li>Ground state is a filled Fermi sea of the lowest-energy spinon states</li><li>Separate up and down spinon sectors (SU(2) symmetry)</li></ol><p><strong>Arguments</strong></p><ul><li><code>H_mat::Matrix{ComplexF64}</code>: Single-particle spinon Hamiltonian matrix</li><li><code>N_up::Int</code>: Number of up-spin spinons to fill</li><li><code>N_down::Int</code>: Number of down-spin spinons to fill</li></ul><p><strong>Returns</strong></p><ul><li><code>(U_up, U_down)</code>: Matrices whose columns are the occupied spinon orbitals<ul><li><code>U_up</code>: N_up lowest eigenvectors for up spinons</li><li><code>U_down</code>: N_down lowest eigenvectors for down spinons</li></ul></li></ul><p><strong>Physics Notes</strong></p><ul><li>The spinon filling typically corresponds to the original spin-1/2 density</li><li>For a spin-1/2 system: N<em>up + N</em>down = total number of spins</li><li>The specific choice of N<em>up, N</em>down determines the magnetic properties</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L356-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.reevaluateW!-Tuple{MC}" href="#KagomeDSL.reevaluateW!-Tuple{MC}"><code>KagomeDSL.reevaluateW!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reevaluateW!(mc::MC)</code></pre><p>Recalculate the one-particle Green&#39;s function matrices W<em>up and W</em>down.</p><p>This function reconstructs the Green&#39;s functions from the current spin configuration by solving the linear systems involving the tilde_U matrices.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo state object</li></ul><p><strong>Algorithm</strong></p><ol><li>Construct tilde_U matrices from current kappa configurations</li><li>Solve linear systems: <span>$tilde_U_up \ I$</span> and <span>$tilde_U_down \ I$</span></li><li>Compute Green&#39;s functions: <span>$W = U * (tilde_U \ I)$</span></li></ol><p><strong>Note</strong></p><p><span>$U \ I$</span> is numerically more stable than computing the inverse directly.</p><p>The Green&#39;s function matrices W represent the one-particle propagators <span>$⟨x|cᵢ⁺cⱼ|ψ⟩/⟨x|ψ⟩$</span> for the current configuration.</p><p>Periodic re-evaluation is necessary to override numerical instability that accumulates from repeated rank-1 updates to the Green&#39;s function matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L30-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}" href="#KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}"><code>KagomeDSL.spinInteraction!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">spinInteraction!(xprime, kappa_up, kappa_down, i, j)</code></pre><p>Compute the transverse (spin-flip) part of the Heisenberg interaction.</p><p>For the Heisenberg Hamiltonian H = J ∑<em>{&lt;i,j&gt;} (S^+</em>i S^-<em>j + S^-</em>i S^+<em>j + S^z</em>i S^z<em>j), this function handles the transverse terms S^+</em>i S^-<em>j + S^-</em>i S^+_j.</p><p>In the spinon representation:</p><ul><li>S^+<em>i S^-</em>j = f^†<em>{i↑} f</em>{i↓} f^†<em>{j↓} f</em>{j↑} (flips spins at both sites)</li><li>S^-<em>i S^+</em>j = f^†<em>{i↓} f</em>{i↑} f^†<em>{j↑} f</em>{j↓} (flips spins at both sites)</li></ul><p>These terms change the spinon configuration and are the source of quantum fluctuations.</p><p><strong>Arguments</strong></p><ul><li><code>xprime::Dict</code>: Dictionary storing new configurations and their amplitudes</li><li><code>kappa_up::Vector{Int}</code>: Current up-spinon configuration</li><li><code>kappa_down::Vector{Int}</code>: Current down-spinon configuration</li><li><code>i::Int, j::Int</code>: Sites for the spin-flip interaction</li></ul><p><strong>Side Effects</strong></p><ul><li>Adds entries to xprime for each allowed spin-flip process</li><li>Key format: (new<em>up</em>site, old<em>up</em>orbital, new<em>down</em>site, old<em>down</em>orbital)</li><li>Amplitude: -1/2 for each allowed process (negative from Heisenberg coupling)</li></ul><p><strong>Physics Notes</strong></p><ul><li>Only processes that respect the constraint (one spinon per site) are allowed</li><li>Creates quantum entanglement between different spinon configurations</li><li>Essential for accessing quantum spin liquid physics beyond mean-field</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L606-L636">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}" href="#KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}"><code>KagomeDSL.tilde_U</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tilde_U(U::AbstractMatrix, kappa::Vector{Int})</code></pre><p>Construct the tilde_U matrix by selecting and rearranging rows from U.</p><p>The tilde_U matrix is formed by selecting the rows of U corresponding to occupied sites (where kappa[l] ≠ 0) and placing them in the order specified by kappa.</p><p><strong>Arguments</strong></p><ul><li><code>U::AbstractMatrix</code>: Source matrix of size (n × m) where n is number of sites</li><li><code>kappa::Vector{Int}</code>: Configuration vector where non-zero values indicate occupied sites</li></ul><p><strong>Returns</strong></p><ul><li>A matrix of size (m × m) with same element type as U</li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code>: If length(kappa) ≠ number of rows in U</li><li><code>ArgumentError</code>: If kappa does not contain exactly m non-zero entries</li><li><code>BoundsError</code>: If any non-zero kappa value is out of bounds</li></ul><p><strong>Note</strong></p><p>This matrix is used in the construction of the one-particle Green&#39;s function W.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L69-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.unitcell_coord-Tuple{KagomeDSL.AbstractLattice, Int64}" href="#KagomeDSL.unitcell_coord-Tuple{KagomeDSL.AbstractLattice, Int64}"><code>KagomeDSL.unitcell_coord</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitcell_coord(lat::AbstractLattice, s::Int) -&gt; Vector{Float64}</code></pre><p>Compute the real-space coordinate of the unit cell containing site <code>s</code>.</p><p>For DoubleKagome lattice:</p><ul><li>Sites 1-6 belong to unit cell 1, sites 7-12 to unit cell 2, etc.</li><li>Each unit cell has 6 sites arranged in two triangular motifs</li><li>Returns the coordinate of the unit cell origin in real space</li></ul><p><strong>Arguments</strong></p><ul><li><code>lat::AbstractLattice</code>: The lattice structure</li><li><code>s::Int</code>: Site index (1-indexed)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Real-space coordinate of the unit cell origin</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.unitcell_diff-Tuple{KagomeDSL.AbstractLattice, Vector{Float64}, Vector{Float64}}" href="#KagomeDSL.unitcell_diff-Tuple{KagomeDSL.AbstractLattice, Vector{Float64}, Vector{Float64}}"><code>KagomeDSL.unitcell_diff</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitcell_diff(lat, unitcell_coord1, unitcell_coord2) -&gt; (Int, Int)</code></pre><p>Calculate the lattice vector difference between two unit cells in terms of basis vectors (a1, a2).</p><p>This function solves the linear system: unitcell<em>coord1 - unitcell</em>coord2 = dx<em>a1 + dy</em>a2 to find integer coefficients (dx, dy) representing the separation in lattice units.</p><p><strong>Arguments</strong></p><ul><li><code>lat::AbstractLattice</code>: The lattice structure containing basis vectors a1, a2</li><li><code>unitcell_coord1::Vector{Float64}</code>: Real-space coordinate of first unit cell</li><li><code>unitcell_coord2::Vector{Float64}</code>: Real-space coordinate of second unit cell</li></ul><p><strong>Returns</strong></p><ul><li><code>(dx::Int, dy::Int)</code>: Lattice vector coefficients such that coord1 - coord2 = dx<em>a1 + dy</em>a2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/Hamiltonian.jl#L40-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.update_W!-Tuple{AbstractMatrix, Int64, Int64, AbstractVector, AbstractVector}" href="#KagomeDSL.update_W!-Tuple{AbstractMatrix, Int64, Int64, AbstractVector, AbstractVector}"><code>KagomeDSL.update_W!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_W!(W::AbstractMatrix, l::Int, K::Int, col_cache::AbstractVector, row_cache::AbstractVector)</code></pre><p>Perform a rank-1 update on the Green&#39;s function matrix using Sherman-Morrison formula.</p><p><strong>Arguments</strong></p><ul><li><code>W::AbstractMatrix</code>: Green&#39;s function matrix to update</li><li><code>l::Int</code>: Column index for the update</li><li><code>K::Int</code>: Row index for the update</li><li><code>col_cache::AbstractVector</code>: Pre-allocated cache for column operations</li><li><code>row_cache::AbstractVector</code>: Pre-allocated cache for row operations</li></ul><p><strong>Algorithm</strong></p><p>Implements the Sherman-Morrison update: <span>$W&#39;_{I,j} = W_{I,j} - W_{I,l} / W_{K,l} * (W_{K,j} - δ_{l,j})$</span></p><p>This represents a rank-1 update to the matrix inverse that maintains the Green&#39;s function relationship after a single-particle move.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L260-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.update_W_matrices!-Tuple{MC}" href="#KagomeDSL.update_W_matrices!-Tuple{MC}"><code>KagomeDSL.update_W_matrices!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_W_matrices!(mc::MC; K_up::Int, K_down::Int, l_up::Int, l_down::Int)</code></pre><p>Update the one-particle Green&#39;s function matrices using rank-1 updates.</p><p>This function performs simultaneous updates of both W<em>up and W</em>down matrices using the Sherman-Morrison formula for efficient matrix inversion updates.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MC</code>: Monte Carlo state object</li><li><code>K_up::Int</code>: Row index for up-spin matrix update</li><li><code>K_down::Int</code>: Row index for down-spin matrix update  </li><li><code>l_up::Int</code>: Column index for up-spin matrix update</li><li><code>l_down::Int</code>: Column index for down-spin matrix update</li></ul><p><strong>Algorithm</strong></p><p>Performs rank-1 updates: <code>W&#39; = W - (W[:,l] * (W[K,:] - δ_{l,:})&#39;) / W[K,l]</code> for both spin components using pre-allocated cache arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L236-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="KagomeDSL.update_configurations!-Tuple{Any, Vararg{Int64, 5}}" href="#KagomeDSL.update_configurations!-Tuple{Any, Vararg{Int64, 5}}"><code>KagomeDSL.update_configurations!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_configurations!(mc, flag::Int, i::Int, site::Int, l_up::Int, l_down::Int)</code></pre><p>Update both Green&#39;s function matrices and configuration vectors for a spin exchange move.</p><p>This function performs the complete update for a spin exchange between sites i and site, including both the Green&#39;s function matrices (W<em>up, W</em>down) and the configuration vectors (kappa<em>up, kappa</em>down).</p><p><strong>Arguments</strong></p><ul><li><code>mc</code>: Monte Carlo state object</li><li><code>flag::Int</code>: Move type indicator (1 or 2)</li><li><code>i::Int</code>: First site index</li><li><code>site::Int</code>: Second site index</li><li><code>l_up::Int</code>: Up-spin label to move</li><li><code>l_down::Int</code>: Down-spin label to move</li></ul><p><strong>Move Types</strong></p><ul><li><code>flag = 1</code>: Move up-spin from site i to site, down-spin from site to i</li><li><code>flag = 2</code>: Move up-spin from site to i, down-spin from site i to site</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hz-xiaxz/KagomeDSL.jl/blob/b4f55c56759eaabf834192384407db6fb8cbbd35/src/MonteCarlo.jl#L476-L496">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« KagomeDSL</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Monday 27 October 2025 05:31">Monday 27 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
