var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}","page":"Reference","title":"KagomeDSL.DoubleKagome","text":"DoubleKagome(t::Float64, n1::Int, n2::Int, PBC::Tuple{Bool,Bool}; antiPBC=(false,false), trunc=Inf)\n\nConstruct a double unit cell Kagome lattice with 6 sites per unit cell.\n\nUnlike a single unit cell Kagome lattice (which has 3 sites per unit cell forming one triangle), the DoubleKagome lattice contains 6 sites per unit cell arranged in two triangular sublattices. This structure is useful for studying systems with enlarged unit cells or specific magnetic ordering patterns that require the doubled cell geometry.\n\nArguments\n\nt::Float64: Parameter defining the equilateral triangle side length (lattice constant = 2t)\nn1::Int: Number of unit cell repetitions in the a1 direction (must be even)\nn2::Int: Number of unit cell repetitions in the a2 direction  \nPBC::Tuple{Bool,Bool}: Periodic boundary conditions in (a1, a2) directions\nantiPBC::Tuple{Bool,Bool}: Antiperiodic boundary conditions (default: (false, false))\ntrunc::Float64: Truncation parameter (default: Inf, unused in current implementation)\n\nReturns\n\nDoubleKagome: Lattice structure with n1 * n2 * 3 total sites\n\nNotes\n\nThe constraint n1 % 2 == 0 ensures proper tiling of the double unit cell\nTotal number of sites is n1 * n2 * 3 (though each unit cell has 6 sites, n1 counts double-sized cells)\nActual number of unit cells is (n1 ÷ 2) * n2, each containing 6 sites\nLattice vectors: a1 = [4t, 0], a2 = [t, √3*t] \nEach unit cell contains 6 sites arranged in two triangular motifs\n\nExample\n\n# Create a 4×3 DoubleKagome lattice with periodic boundaries\nlat = DoubleKagome(1.0, 4, 3, (true, true))\n# Total sites: 4 * 3 * 3 = 36 sites (2 unit cells × 3 repetitions × 6 sites per unit cell)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Hamiltonian","page":"Reference","title":"KagomeDSL.Hamiltonian","text":"Hamiltonian\n\nComplete specification of the spinon mean-field Hamiltonian for quantum Monte Carlo simulations.\n\nThis structure contains all information needed for Variational  Monte Carlo calculations of quantum spin liquid properties:\n\nFields\n\nN_up::Int: Number of up-spin spinons (determines spin sector)\nN_down::Int: Number of down-spin spinons\nU_up::Matrix{ComplexF64}: Occupied up-spinon orbitals (columns are eigenvectors)\nU_down::Matrix{ComplexF64}: Occupied down-spinon orbitals\nH_mat::Matrix{ComplexF64}: Single-particle spinon Hamiltonian matrix\nnn::AbstractArray: List of nearest-neighbor bonds for efficient iteration\n\nUsage in Monte Carlo\n\nUup, Udown define the reference state (filled Fermi sea)\nH_mat provides the hopping amplitudes for Monte Carlo updates\nnn specifies which bonds to consider in interaction terms\n\nPhysical Interpretation\n\nRepresents a quantum spin liquid state where spins are fractionalized\nCorrelations arise from quantum fluctuations around the mean-field state\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#KagomeDSL.Hamiltonian-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T<:KagomeDSL.AbstractLattice","page":"Reference","title":"KagomeDSL.Hamiltonian","text":"Hamiltonian(N_up, N_down, lat; link_in=pi_link_in, link_inter=pi_link_inter, B=0.0)\n\nConstruct a complete Hamiltonian structure for quantum Monte Carlo simulations.\n\nThis is the main constructor that builds everything needed for SSE Monte Carlo:\n\nConstructs the single-particle spinon Hamiltonian matrix\nDiagonalizes it to find the occupied orbitals\nExtracts the nearest-neighbor bond structure\nPackages everything for efficient Monte Carlo usage\n\nArguments\n\nN_up::Int, N_down::Int: Number of up/down spinons (determines magnetic sector)\nlat::AbstractLattice: Lattice structure (typically DoubleKagome)\nlink_in: Intra-cell hopping dictionary (default: π-flux pattern)\nlink_inter: Inter-cell hopping dictionary (default: π-flux pattern)\nB::Float64: Magnetic field strength for Peierls phases (default: 0.0)\n\nReturns\n\nHamiltonian: Complete structure ready for Monte Carlo simulations\n\nPhysics Notes\n\nThe choice of Nup, Ndown determines the spin sector being studied\nFor spin-1/2 systems: Nup + Ndown = number of original spins\nDifferent (Nup, Ndown) can access different quantum phases\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.MC-Tuple{AbstractDict}","page":"Reference","title":"KagomeDSL.MC","text":"MC(params::AbstractDict)\n\n\n\nCreate a Monte Carlo object from a dictionary of parameters. This is the user-facing, high-level constructor.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.MC-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}, AbstractMatrix, AbstractMatrix}","page":"Reference","title":"KagomeDSL.MC","text":"MC(Ham, kappa_up, kappa_down, W_up, W_down)\n\n\n\nCreate a Monte Carlo object from its core components. This constructor automatically creates the necessary cache arrays. It's useful for internal logic and testing.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.init!-Tuple{MC, MCContext, AbstractDict}","page":"Reference","title":"Carlo.init!","text":"Carlo.init!(mc::MC, ctx::MCContext, params::AbstractDict)\n\n\n\nInitialize the Monte Carlo object params\n\nn1 : Int number of cells in x direction\nn2 : Int number of cells in y direction\nPBC : Tuple{Bool,2} boundary condition, e.g. (false, false)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.read_checkpoint!-Tuple{MC, HDF5.Group}","page":"Reference","title":"Carlo.read_checkpoint!","text":"Carlo.read_checkpoint!(mc::MC, in::HDF5.Group)\n\nRestore Monte Carlo state from saved checkpoint for simulation continuation.\n\nPurpose: Loads previously saved spinon configurations to resume a simulation  from a specific state or initialize postprocessing analysis.\n\nArguments\n\nmc::MC: Monte Carlo object to restore (modified in-place)\nin::HDF5.Group: Input HDF5 group containing checkpoint data\n\nRestored Data\n\nkappa_up: Up-spinon configuration vector\nkappa_down: Down-spinon configuration vector\n\nUsage Contexts\n\nSimulation resumption: Continue interrupted long simulations\nPostprocessing initialization: Start analysis from specific configurations\nReproducibility: Restore exact simulation states\n\nSide Effects\n\nModifies mc.kappaup and mc.kappadown in-place\nOverwrites current Monte Carlo configuration completely\n\nNotes\n\nCalled automatically by Carlo.jl when resuming from checkpoints  \nEssential for maintaining simulation continuity\nEnables reproducible analysis workflows\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.register_evaluables-Tuple{Type{MC}, Carlo.Evaluator, AbstractDict}","page":"Reference","title":"Carlo.register_evaluables","text":"Carlo.register_evaluables(::Type{MC}, eval::Evaluator, params::AbstractDict)\n\nRegister postprocessing evaluators for final analysis after Monte Carlo simulation.\n\nIMPORTANT: This is purely for postprocessing - these evaluators are executed  at the end of the simulation or during merge operations to compute final observables  from the collected raw measurements. They do NOT affect the Monte Carlo dynamics.\n\nThis function defines how to compute physical observables from the raw measured  data (:OL values) that was collected during the simulation via Carlo.measure!().\n\nArguments\n\n::Type{MC}: Monte Carlo type dispatch\neval::Evaluator: Carlo.jl evaluator for postprocessing computations\nparams::AbstractDict: Simulation parameters containing lattice dimensions\n\nRegistered Evaluables\n\n:energy: Computes the energy per site from local energy measurements\nFormula: energy = ⟨OL⟩ / ns, where ns = total number of sites\nInput: Raw :OL measurements collected during simulation\nOutput: Normalized energy per site for final results\n\nUsage in Carlo.jl Workflow\n\nDuring simulation: Carlo.measure!() collects raw :OL data\nAfter simulation: This function defines how to postprocess the data\nFinal analysis: Carlo.jl automatically applies these evaluators to compute final results\nMerge operations: Used when combining data from multiple simulation runs\n\nPhysics Notes\n\nOL represents the local energy estimator ⟨x|H|ψG⟩/⟨x|ψG⟩\nNormalization by ns gives energy per site (intensive quantity)\nEssential for comparing results across different system sizes\n\nPerformance Notes\n\nCalled only once during setup, not during simulation loops\nActual evaluation happens in postprocessing phase\nMinimal computational overhead during Monte Carlo sampling\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.sweep!-Tuple{MC, MCContext}","page":"Reference","title":"Carlo.sweep!","text":"Carlo.sweep!(mc::MC, ctx::MCContext) -> Nothing\n\nPerform one Monte Carlo sweep for the Mott state simulation. This implements a two-spin swap update where electrons can exchange positions between different spin states at occupied sites.\n\nNote: The W matrices are re-evaluated periodically (every n_occupied sweeps) to maintain numerical stability. If the re-evaluation fails due to singular matrices, a warning is issued and the simulation continues.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.write_checkpoint-Tuple{MC, HDF5.Group}","page":"Reference","title":"Carlo.write_checkpoint","text":"Carlo.write_checkpoint(mc::MC, out::HDF5.Group)\n\nSave Monte Carlo state for resuming simulations or postprocessing analysis.\n\nPurpose: Serializes the current spinon configuration to an HDF5 file for later  use in simulation continuation or postprocessing workflows.\n\nArguments\n\nmc::MC: Monte Carlo state to save\nout::HDF5.Group: Output HDF5 group for writing checkpoint data\n\nSaved Data\n\nkappa_up: Current up-spinon configuration vector\nkappa_down: Current down-spinon configuration vector\n\nUsage Contexts\n\nSimulation checkpointing: Save state for restarting long simulations\nPostprocessing: Preserve final configurations for additional analysis\nData archival: Store representative configurations for later study\n\nNotes\n\nCalled automatically by Carlo.jl during simulation checkpointing\nEssential for resuming interrupted simulations\nEnables analysis of specific configurations post-simulation\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Hmat-Tuple{DoubleKagome}","page":"Reference","title":"KagomeDSL.Hmat","text":"Hmat(\n    lat::DoubleKagome;\n    link_in = pi_link_in,\n    link_inter = pi_link_inter,\n    B = 0.0,\n) -> Matrix{ComplexF64}\n\nConstructs the Spinon Hamiltonian matrix for a DoubleKagome lattice.\n\nThis function calculates the hopping terms within and between unit cells, incorporating a Peierls phase to account for a magnetic field B. The resulting matrix represents the Hamiltonian of the system.\n\nArguments\n\nlat::DoubleKagome: The lattice structure for which to construct the Hamiltonian.\nlink_in: A dictionary defining in-cell hopping terms. Defaults to pi_link_in.\nlink_inter: A dictionary defining inter-cell hopping terms. Defaults to pi_link_inter.\nB::Float64: The magnetic field strength, used to calculate the Peierls phase. Defaults to 0.0.\n\nReturns\n\nMatrix{ComplexF64}: The Hamiltonian matrix for the given lattice and parameters.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.Sz","text":"Sz(i::Int, kappa_up::Vector{Int}, kappa_down::Vector{Int}) -> Float64\n\nCalculate the z-component of spin at site i in the spinon representation.\n\nIn the spinon formulation, the original spin operators are written as:\n\nS^zi = 1/2 (f^†{i↑} f{i↑} - f^†{i↓} f_{i↓})\nS^+i = f^†{i↑} f{i↓}, S^-i = f^†{i↓} f{i↑}\n\nwhere f{iσ} are spinon annihilation operators. The constraint is exactly one  spinon per site: n{i↑} + n_{i↓} = 1 (no double occupancy or empty sites).\n\nArguments\n\ni::Int: Site index (1-indexed)\nkappa_up::Vector{Int}: Up-spinon configuration (0 = empty, nonzero = occupied)\nkappa_down::Vector{Int}: Down-spinon configuration\n\nReturns\n\nFloat64: +0.5 for up spin, -0.5 for down spin\n\nExceptions\n\nArgumentError: If site is doubly occupied or empty (violates spinon constraint)\nBoundsError: If i is outside valid range [1, length(kappa_up)]\nDimensionMismatch: If kappaup and kappadown have different lengths\n\nPhysics Notes\n\nThis enforces the constraint that each site has exactly one spinon\nConfigurations violating the constraint (empty or doubly occupied) are unphysical\nUsed in Monte Carlo to measure local magnetization and Ising interactions\nThe spinon constraint is fundamental to the validity of the spin liquid state\n\nPerformance Notes\n\nMarked @inline for performance in Monte Carlo loops\nUses @boundscheck for optional bounds checking\nCalls is_occupied() helper function for spinon occupancy detection\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.SzInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}","page":"Reference","title":"KagomeDSL.SzInteraction!","text":"SzInteraction!(xprime, kappa_up, kappa_down, i, j)\n\nCompute the Ising (S^z S^z) interaction term for the Heisenberg Hamiltonian.\n\nFor the Heisenberg model H = J ∑{<i,j>} (S^+i S^-j + S^-i S^+j + S^zi S^zj), this function handles the S^zi S^z_j term, which is diagonal in the spinon basis.\n\nThe Ising term doesn't change the spinon configuration, so it contributes to the identity component of the operator expansion (stored with key (-1,-1,-1,-1)).\n\nArguments\n\nxprime::Dict: Dictionary storing operator expansion coefficients\nkappa_up::Vector{Int}: Current up-spinon configuration\nkappa_down::Vector{Int}: Current down-spinon configuration  \ni::Int, j::Int: Sites for the interaction\n\nSide Effects\n\nModifies xprime[(-1,-1,-1,-1)] by adding Sz(i) * Sz(j)\n\nPhysics Notes\n\nThis is the \"easy-axis\" part of the Heisenberg interaction\nDiagonal in the occupation basis, doesn't create/destroy spinons\nCombined with spinInteraction!() to give the full Heisenberg model\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.apply_boundary_conditions!-Tuple{AbstractMatrix, KagomeDSL.AbstractLattice, Int64, Int64, Dict, Float64}","page":"Reference","title":"KagomeDSL.apply_boundary_conditions!","text":"apply_boundary_conditions!(tunneling, lat, s1, s2, link_inter, B)\n\nApply boundary conditions and magnetic field effects to inter-cell hopping terms.\n\nThis function modifies the tunneling matrix by adding all possible hopping paths  between sites s1 and s2, considering:\n\nPeriodic/antiperiodic boundary conditions\nPeierls phase factors from magnetic field B\nπ-flux pattern encoded in link_inter dictionary\n\nArguments\n\ntunneling::AbstractMatrix: Hopping matrix to be modified (in-place)\nlat::AbstractLattice: Lattice structure with boundary conditions\ns1::Int, s2::Int: Source and target site indices\nlink_inter::Dict: Inter-cell hopping amplitudes with (label1, label2, dx, dy) keys\nB::Float64: Magnetic field strength for Peierls phase calculation\n\nPhysics Details\n\nPeierls phase: exp(iB/2 * (x1+x2)(y2-y1)) accounts for vector potential A = (0, Bx)\nEach boundary crossing can contribute ±1 phase factor from antiperiodic BC\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.find_initial_configuration!-Tuple{MC, Int64, Int64}","page":"Reference","title":"KagomeDSL.find_initial_configuration!","text":"find_initial_configuration!(mc::MC, rng::AbstractRNG, ns::Int, N_up::Int, n1::Int)\n\nFinds a non-singular initial configuration for the MC simulation. This version uses a deterministic QR-based method and should not require retries.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.getOL","text":"getOL(mc::AbstractMC, kappa_up, kappa_down) -> Float64\n\nCompute the local energy estimator for quantum Monte Carlo.\n\nCalculates the observable OL = ⟨x|H|ψG⟩/⟨x|ψ_G⟩, which provides an unbiased estimator of the ground state energy in the Stochastic Series Expansion method.\n\nIn the spinon mean-field framework:\n\n|ψ_G⟩ is the Slater Determinant spinon state (Gutzwiller projected)\n|x⟩ = |κup⟩ ⊗ |κdown⟩ is a particular spinon configuration\nH is the original Heisenberg Hamiltonian (not the mean-field one!)\n\nThe ratio gives the local contribution to the energy from configuration |x⟩.\n\nArguments\n\nmc::AbstractMC: Monte Carlo state containing Wup, Wdown matrices\nkappa_up::Vector{Int}: Current up-spinon configuration\nkappa_down::Vector{Int}: Current down-spinon configuration\n\nReturns\n\nFloat64: Local energy contribution from this configuration\n\nAlgorithm\n\nCompute H|x⟩ using getxprime() to get all reachable configurations\nFor diagonal terms: directly add the Ising contributions\nFor off-diagonal terms: weight by the wavefunction amplitude ratios Wup, Wdown\nSum all contributions to get the local energy\n\nPhysics Notes\n\nThis is the \"local energy\" in variational Monte Carlo terminology\nFluctuations in O_L reflect the quality of the trial wavefunction\nUsed to measure energy and other observables in quantum spin liquids\nThe Hamiltonian H must be the original physical one, not the mean-field approximation\n\nPerformance Notes\n\nCritical function called in every Monte Carlo step\nBounds checking disabled with @inbounds for performance\nUses efficient iteration over pairs() for dictionary access\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.get_boundary_shifts-Tuple{KagomeDSL.AbstractLattice, Int64, Int64}","page":"Reference","title":"KagomeDSL.get_boundary_shifts","text":"get_boundary_shifts(lat::AbstractLattice, s1::Int, s2::Int) -> Vector{Tuple{Int,Int,Float64}}\n\nCalculate all possible lattice vector shifts between sites s1 and s2 under periodic/antiperiodic boundary conditions.\n\nFor quantum spin systems with twisted boundary conditions:\n\nPeriodic BC: ψ(r + L) = ψ(r)\nAntiperiodic BC: ψ(r + L) = -ψ(r)\n\nReturns all equivalent separations considering lattice periodicity, with associated phase factors.\n\nArguments\n\nlat::AbstractLattice: Lattice with boundary condition specifications\ns1::Int, s2::Int: Site indices for the hopping term\n\nReturns\n\nVector{Tuple{Int,Int,Float64}}: List of (dx, dy, sign) tuples where:\ndx, dy: Lattice vector coefficients\nsign: Phase factor (±1) from antiperiodic boundary crossings\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.get_nn-Tuple{AbstractMatrix}","page":"Reference","title":"KagomeDSL.get_nn","text":"get_nn(H_mat::AbstractMatrix) -> Vector{Tuple{Int,Int}}\n\nExtract nearest-neighbor bond list from the Hamiltonian matrix.\n\nFinds all non-zero off-diagonal elements in the upper triangular part of H_mat, which correspond to hopping terms between connected sites. Essential for efficient Monte Carlo sampling since we only need to consider active bonds.\n\nArguments\n\nH_mat::AbstractMatrix: Hamiltonian matrix (typically hermitian)\n\nReturns\n\nVector{Tuple{Int,Int}}: List of (i,j) pairs where i < j and H_mat[i,j] ≠ 0\n\nNotes\n\nOnly upper triangular elements to avoid double-counting\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.get_site_coord-Tuple{KagomeDSL.AbstractLattice, Int64}","page":"Reference","title":"KagomeDSL.get_site_coord","text":"get_site_coord(lat::AbstractLattice, s::Int) -> Vector{Float64}\n\nCalculate the real-space coordinate of site s in the lattice.\n\nCombines the unit cell position with the intra-cell site offset to give the absolute position in real space. Essential for calculating Peierls phases and analyzing spatial correlations.\n\nArguments\n\nlat::AbstractLattice: Lattice structure\ns::Int: Site index (1-indexed)\n\nReturns\n\nVector{Float64}: [x, y] coordinate in real space\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.getxprime","text":"getxprime(Ham::Hamiltonian, kappa_up, kappa_down) -> Dict{NTuple{4,Int}, Float64}\n\nCompute the action of the Heisenberg Hamiltonian on a spinon configuration.\n\nThis is the core function for Stochastic Series Expansion (SSE) Monte Carlo. Given a spinon configuration |κup, κdown⟩, it computes all configurations  |κ'up, κ'down⟩ that can be reached by applying H, along with their amplitudes.\n\nThe result is H|κ⟩ = Σ_κ' xprime[κ'] |κ'⟩, where xprime encodes the expansion.\n\nArguments\n\nHam::Hamiltonian: Complete Hamiltonian specification\nkappa_up::Vector{Int}: Current up-spinon configuration\nkappa_down::Vector{Int}: Current down-spinon configuration\n\nReturns\n\nDict{NTuple{4,Int}, Float64}: Dictionary mapping configurations to amplitudes\nKey (-1,-1,-1,-1): Diagonal contribution (Ising terms)\nKey (i,lup,j,ldown): Off-diagonal contribution from spin-flip at sites i,j\n\nAlgorithm\n\nIterate over all nearest-neighbor bonds in Ham.nn\nFor each bond, compute Ising (S^z S^z) and transverse (S^+ S^- + S^- S^+) terms\nAccumulate results in xprime dictionary\n\nUsage in Monte Carlo\n\nCalled during each Monte Carlo update to propose new configurations\nThe amplitudes determine acceptance probabilities for updates\nEssential for sampling the quantum mechanical evolution\n\nPhysics Notes\n\n|x⟩ must be a valid Mott state (one spinon per site)\nThe Hamiltonian H is the original Heisenberg model, not the mean-field one\nCombines both diagonal (Ising) and off-diagonal (transverse) contributions\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.init_conf_qr!-Tuple{MC, Int64, Int64}","page":"Reference","title":"KagomeDSL.init_conf_qr!","text":"init_conf_qr!(mc::MC, ns::Int, N_up::Int)\n\nRef: Quantum Monte Carlo Approaches for Correlated Systems (Becca and Sorella, 2017) P130\n\nAs system size increases, Φx becomes exponentially small comparing to system size, inversely proportional to the dimension of the Hilbert space.\n\nThe smallness of init Φx will lead to numerical instability in the first computation of the W matrices, but not affecting the Markov chain sampling, since we always calculate fracΦxΦx there, which shall not be a numerically instable number.\n\nTo avoid this issue we initializes the particle configurations kappa_up and kappa_down in the mc object using a deterministic method based on QR decomposition with column pivoting.\n\nThis approach is designed to select a set of sites for the up and down spin electrons that corresponds to a set of linearly independent rows from the U_up and U_down matrices, respectively. This maximizes the chances of producing a non-singular tilde_U matrix, avoiding the need for random trial-and-error.\n\nThe procedure is as follows:\n\nIt performs QR decomposition on mc.Ham.U_up' to select the N_up most  linearly independent rows (sites) for the up-spin electrons.\nIt then takes the remaining, unoccupied sites and performs a second QR  decomposition on the corresponding subset of mc.Ham.U_down' to select the  N_down sites for the down-spin electrons.\n\nParameters:\n\nmc: The Monte Carlo object, which will be modified in-place.\nns: The total number of sites in the lattice.\nN_up: The number of up-spin electrons.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}","page":"Reference","title":"KagomeDSL.is_occupied","text":"is_occupied(kappa::Vector{Int}, l::Int) -> Bool\n\nCheck if site l is occupied in the kappa configuration vector.\n\nThrows:     BoundsError: if l is outside the valid range of kappa\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.orbitals-Tuple{Matrix{ComplexF64}, Int64, Int64}","page":"Reference","title":"KagomeDSL.orbitals","text":"orbitals(H_mat::Matrix{ComplexF64}, N_up::Int, N_down::Int) -> (Matrix{ComplexF64}, Matrix{ComplexF64})\n\nCompute the occupied spinon orbitals for the quantum spin liquid ground state.\n\nIn the spinon mean-field theory:\n\nSpins are fractionalized into spinons (fermionic particles carrying spin-1/2)\nThe Hamiltonian H_mat describes spinon hopping on the lattice\nGround state is a filled Fermi sea of the lowest-energy spinon states\nSeparate up and down spinon sectors (SU(2) symmetry)\n\nArguments\n\nH_mat::Matrix{ComplexF64}: Single-particle spinon Hamiltonian matrix\nN_up::Int: Number of up-spin spinons to fill\nN_down::Int: Number of down-spin spinons to fill\n\nReturns\n\n(U_up, U_down): Matrices whose columns are the occupied spinon orbitals\nU_up: N_up lowest eigenvectors for up spinons\nU_down: N_down lowest eigenvectors for down spinons\n\nPhysics Notes\n\nThe spinon filling typically corresponds to the original spin-1/2 density\nFor a spin-1/2 system: Nup + Ndown = total number of spins\nThe specific choice of Nup, Ndown determines the magnetic properties\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}","page":"Reference","title":"KagomeDSL.spinInteraction!","text":"spinInteraction!(xprime, kappa_up, kappa_down, i, j)\n\nCompute the transverse (spin-flip) part of the Heisenberg interaction.\n\nFor the Heisenberg Hamiltonian H = J ∑{<i,j>} (S^+i S^-j + S^-i S^+j + S^zi S^zj), this function handles the transverse terms S^+i S^-j + S^-i S^+_j.\n\nIn the spinon representation:\n\nS^+i S^-j = f^†{i↑} f{i↓} f^†{j↓} f{j↑} (flips spins at both sites)\nS^-i S^+j = f^†{i↓} f{i↑} f^†{j↑} f{j↓} (flips spins at both sites)\n\nThese terms change the spinon configuration and are the source of quantum fluctuations.\n\nArguments\n\nxprime::Dict: Dictionary storing new configurations and their amplitudes\nkappa_up::Vector{Int}: Current up-spinon configuration\nkappa_down::Vector{Int}: Current down-spinon configuration\ni::Int, j::Int: Sites for the spin-flip interaction\n\nSide Effects\n\nAdds entries to xprime for each allowed spin-flip process\nKey format: (newupsite, olduporbital, newdownsite, olddownorbital)\nAmplitude: -1/2 for each allowed process (negative from Heisenberg coupling)\n\nPhysics Notes\n\nOnly processes that respect the constraint (one spinon per site) are allowed\nCreates quantum entanglement between different spinon configurations\nEssential for accessing quantum spin liquid physics beyond mean-field\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}","page":"Reference","title":"KagomeDSL.tilde_U","text":"tilde_U(U::AbstractMatrix, kappa::Vector{Int})\n\n\n\nCreates a tilde matrix by rearranging rows of U according to kappa indices.\n\nParameters:\n\nU: Source matrix of size (n × m)\nkappa: Vector of indices where each non-zero value l indicates that row Rl of U         should be placed at row l of the output\n\nReturns:\n\nA matrix of size (m × m) with same element type as U\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.unitcell_coord-Tuple{KagomeDSL.AbstractLattice, Int64}","page":"Reference","title":"KagomeDSL.unitcell_coord","text":"unitcell_coord(lat::AbstractLattice, s::Int) -> Vector{Float64}\n\nCompute the real-space coordinate of the unit cell containing site s.\n\nFor DoubleKagome lattice:\n\nSites 1-6 belong to unit cell 1, sites 7-12 to unit cell 2, etc.\nEach unit cell has 6 sites arranged in two triangular motifs\nReturns the coordinate of the unit cell origin in real space\n\nArguments\n\nlat::AbstractLattice: The lattice structure\ns::Int: Site index (1-indexed)\n\nReturns\n\nVector{Float64}: Real-space coordinate of the unit cell origin\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.unitcell_diff-Tuple{KagomeDSL.AbstractLattice, Vector{Float64}, Vector{Float64}}","page":"Reference","title":"KagomeDSL.unitcell_diff","text":"unitcell_diff(lat, unitcell_coord1, unitcell_coord2) -> (Int, Int)\n\nCalculate the lattice vector difference between two unit cells in terms of basis vectors (a1, a2).\n\nThis function solves the linear system: unitcellcoord1 - unitcellcoord2 = dxa1 + dya2 to find integer coefficients (dx, dy) representing the separation in lattice units.\n\nArguments\n\nlat::AbstractLattice: The lattice structure containing basis vectors a1, a2\nunitcell_coord1::Vector{Float64}: Real-space coordinate of first unit cell\nunitcell_coord2::Vector{Float64}: Real-space coordinate of second unit cell\n\nReturns\n\n(dx::Int, dy::Int): Lattice vector coefficients such that coord1 - coord2 = dxa1 + dya2\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.update_W!-Tuple{AbstractMatrix, Int64, Int64, AbstractVector, AbstractVector}","page":"Reference","title":"KagomeDSL.update_W!","text":"update_W!(W::AbstractMatrix; l::Int, K::Int)\n\n\n\nUpdate the W matrix W_Ij = W_Ij - W_Il  W_Kl * (W_Kj - delta_lj)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.update_W_matrices!-Tuple{MC}","page":"Reference","title":"KagomeDSL.update_W_matrices!","text":"update_W_matrices(mc::MC; K_up::Int, K_down::Int, l_up::Int, l_down::Int)\n\n\n\nUpdate the W matrices\n\n\n\n\n\n","category":"method"},{"location":"#KagomeDSL","page":"KagomeDSL","title":"KagomeDSL","text":"","category":"section"},{"location":"","page":"KagomeDSL","title":"KagomeDSL","text":"Documentation for KagomeDSL.","category":"page"}]
}
