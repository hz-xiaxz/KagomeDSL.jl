var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}","page":"Reference","title":"KagomeDSL.DoubleKagome","text":"double triangle unit cell Kagome lattice\n\nnote n1 here is still the number of repititions of triangle in the a1 direction, so n1 is asserted to be even. The total number is n1 * n2 * 3 sites.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.MC-Tuple{AbstractDict}","page":"Reference","title":"KagomeDSL.MC","text":"MC(params::AbstractDict)\n\n\n\nCreate a Monte Carlo object from a dictionary of parameters. This is the user-facing, high-level constructor.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.MC-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}, AbstractMatrix, AbstractMatrix}","page":"Reference","title":"KagomeDSL.MC","text":"MC(Ham, kappa_up, kappa_down, W_up, W_down)\n\n\n\nCreate a Monte Carlo object from its core components. This constructor automatically creates the necessary cache arrays. It's useful for internal logic and testing.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.init!-Tuple{MC, MCContext, AbstractDict}","page":"Reference","title":"Carlo.init!","text":"Carlo.init!(mc::MC, ctx::MCContext, params::AbstractDict)\n\n\n\nInitialize the Monte Carlo object params\n\nn1 : Int number of cells in x direction\nn2 : Int number of cells in y direction\nPBC : Tuple{Bool,2} boundary condition, e.g. (false, false)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.sweep!-Tuple{MC, MCContext}","page":"Reference","title":"Carlo.sweep!","text":"Carlo.sweep!(mc::MC, ctx::MCContext) -> Nothing\n\nPerform one Monte Carlo sweep for the Mott state simulation. This implements a two-spin swap update where electrons can exchange positions between different spin states at occupied sites.\n\nNote: The W matrices are re-evaluated periodically (every n_occupied sweeps) to maintain numerical stability. If the re-evaluation fails due to singular matrices, a warning is issued and the simulation continues.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Hmat-Tuple{DoubleKagome}","page":"Reference","title":"KagomeDSL.Hmat","text":"Hmat(\n    lat::DoubleKagome;\n    link_in = pi_link_in,\n    link_inter = pi_link_inter,\n    B = 0.0,\n) -> Matrix{ComplexF64}\n\nConstructs the Spinon Hamiltonian matrix for a DoubleKagome lattice.\n\nThis function calculates the hopping terms within and between unit cells, incorporating a Peierls phase to account for a magnetic field B. The resulting matrix represents the Hamiltonian of the system.\n\nArguments\n\nlat::DoubleKagome: The lattice structure for which to construct the Hamiltonian.\nlink_in: A dictionary defining in-cell hopping terms. Defaults to pi_link_in.\nlink_inter: A dictionary defining inter-cell hopping terms. Defaults to pi_link_inter.\nB::Float64: The magnetic field strength, used to calculate the Peierls phase. Defaults to 0.0.\n\nReturns\n\nMatrix{ComplexF64}: The Hamiltonian matrix for the given lattice and parameters.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.Sz","text":"Sz(i::Int, kappa_up::Vector{Int}, kappa_down::Vector{Int}) -> Float64\n\nSz = 12 (f^_ f_ - f^_ f_) Calculate the z-component of spin at site i given up and down spin configurations.\n\nReturns:     +1/2 for up spin     -1/2 for down spin\n\nThrows:     ArgumentError: if site is doubly occupied or empty     BoundsError: if i is outside the valid range\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.find_initial_configuration!-Tuple{MC, Int64, Int64}","page":"Reference","title":"KagomeDSL.find_initial_configuration!","text":"find_initial_configuration!(mc::MC, rng::AbstractRNG, ns::Int, N_up::Int, n1::Int)\n\nFinds a non-singular initial configuration for the MC simulation. This version uses a deterministic QR-based method and should not require retries.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.getOL","text":"The observable O_L = fracxHpsi_Gxpsi_G The Hamiltonian should be the real one!\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.getxprime","text":"return x = Hx  where H is the Heisenberg Hamiltonian Note x here should also be a Mott state.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.init_conf_qr!-Tuple{MC, Int64, Int64}","page":"Reference","title":"KagomeDSL.init_conf_qr!","text":"init_conf_qr!(mc::MC, ns::Int, N_up::Int)\n\nRef: Quantum Monte Carlo Approaches for Correlated Systems (Becca and Sorella, 2017) P130\n\nAs system size increases, Φx becomes exponentially small comparing to system size, inversely proportional to the dimension of the Hilbert space.\n\nThe smallness of init Φx will lead to numerical instability in the first computation of the W matrices, but not affecting the Markov chain sampling, since we always calculate fracΦxΦx there, which shall not be a numerically instable number.\n\nTo avoid this issue we initializes the particle configurations kappa_up and kappa_down in the mc object using a deterministic method based on QR decomposition with column pivoting.\n\nThis approach is designed to select a set of sites for the up and down spin electrons that corresponds to a set of linearly independent rows from the U_up and U_down matrices, respectively. This maximizes the chances of producing a non-singular tilde_U matrix, avoiding the need for random trial-and-error.\n\nThe procedure is as follows:\n\nIt performs QR decomposition on mc.Ham.U_up' to select the N_up most  linearly independent rows (sites) for the up-spin electrons.\nIt then takes the remaining, unoccupied sites and performs a second QR  decomposition on the corresponding subset of mc.Ham.U_down' to select the  N_down sites for the down-spin electrons.\n\nParameters:\n\nmc: The Monte Carlo object, which will be modified in-place.\nns: The total number of sites in the lattice.\nN_up: The number of up-spin electrons.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}","page":"Reference","title":"KagomeDSL.is_occupied","text":"is_occupied(kappa::Vector{Int}, l::Int) -> Bool\n\nCheck if site l is occupied in the kappa configuration vector.\n\nThrows:     BoundsError: if l is outside the valid range of kappa\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}","page":"Reference","title":"KagomeDSL.spinInteraction!","text":"spinInteraction!(xprime::Dict, kappa_up::Vector{Int}, kappa_down::Vector{Int}, i::Int, j::Int)\n\nCompute the spin flip term 1/2(S+i S-j + S-i S+j) contribution to xprime.\n\nThe function handles two cases:\n\nS+i S-j: when j has up spin and i has down spin\nS-i S+j: when i has up spin and j has down spin\n\nEach case contributes with coefficient 1/2.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}","page":"Reference","title":"KagomeDSL.tilde_U","text":"tilde_U(U::AbstractMatrix, kappa::Vector{Int})\n\n\n\nCreates a tilde matrix by rearranging rows of U according to kappa indices.\n\nParameters:\n\nU: Source matrix of size (n × m)\nkappa: Vector of indices where each non-zero value l indicates that row Rl of U         should be placed at row l of the output\n\nReturns:\n\nA matrix of size (m × m) with same element type as U\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.update_W!-Tuple{AbstractMatrix, Int64, Int64, AbstractVector, AbstractVector}","page":"Reference","title":"KagomeDSL.update_W!","text":"update_W!(W::AbstractMatrix; l::Int, K::Int)\n\n\n\nUpdate the W matrix W_Ij = W_Ij - W_Il  W_Kl * (W_Kj - delta_lj)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.update_W_matrices!-Tuple{MC}","page":"Reference","title":"KagomeDSL.update_W_matrices!","text":"update_W_matrices(mc::MC; K_up::Int, K_down::Int, l_up::Int, l_down::Int)\n\n\n\nUpdate the W matrices\n\n\n\n\n\n","category":"method"},{"location":"#KagomeDSL","page":"KagomeDSL","title":"KagomeDSL","text":"","category":"section"},{"location":"","page":"KagomeDSL","title":"KagomeDSL","text":"Documentation for KagomeDSL.","category":"page"}]
}
