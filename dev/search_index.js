var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}","page":"Reference","title":"KagomeDSL.DoubleKagome","text":"double triangle unit cell Kagome lattice\n\nnote n1 here is still the number of repititions of triangle in the a1 direction, so n1 is asserted to be even. The total number is n1 * n2 * 3 sites.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.MC-Tuple{AbstractDict}","page":"Reference","title":"KagomeDSL.MC","text":"MC(params::AbstractDict)\n\n\n\nCreate a Monte Carlo object\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.init!-Tuple{MC, MCContext, AbstractDict}","page":"Reference","title":"Carlo.init!","text":"Carlo.init!(mc::MC, ctx::MCContext, params::AbstractDict)\n\n\n\nInitialize the Monte Carlo object params\n\nn1 : Int number of cells in x direction\nn2 : Int number of cells in y direction\nPBC : Tuple{Bool,2} boundary condition, e.g. (false, false)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.sweep!-Tuple{MC, MCContext}","page":"Reference","title":"Carlo.sweep!","text":"Carlo.sweep!(mc::MC, ctx::MCContext) -> Nothing\n\nPerform one Monte Carlo sweep for the Mott state simulation. This implements a two-spin swap update where electrons can exchange positions between different spin states at occupied sites.\n\nNote: The W matrices are re-evaluated periodically (every n_occupied sweeps) to maintain numerical stability. If the re-evaluation fails due to singular matrices, a warning is issued and the simulation continues.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Hmat-Tuple{DoubleKagome}","page":"Reference","title":"KagomeDSL.Hmat","text":"Hmat(lat::DoubleKagome) -> Matrix{Float64}\n\nReturn the Spinor Hamiltonian matrix for a DoubleKagome lattice.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.Sz","text":"Sz(i::Int, kappa_up::Vector{Int}, kappa_down::Vector{Int}) -> Float64\n\nSz = 12 (f^_ f_ - f^_ f_) Calculate the z-component of spin at site i given up and down spin configurations.\n\nReturns:     +1/2 for up spin     -1/2 for down spin\n\nThrows:     ArgumentError: if site is doubly occupied or empty     BoundsError: if i is outside the valid range\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.getOL","text":"The observable O_L = fracxHpsi_Gxpsi_G The Hamiltonian should be the real one!\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.getxprime","text":"return x = Hx  where H is the Heisenberg Hamiltonian Note x here should also be a Mott state.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}","page":"Reference","title":"KagomeDSL.is_occupied","text":"is_occupied(kappa::Vector{Int}, l::Int) -> Bool\n\nCheck if site l is occupied in the kappa configuration vector.\n\nThrows:     BoundsError: if l is outside the valid range of kappa\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}","page":"Reference","title":"KagomeDSL.spinInteraction!","text":"spinInteraction!(xprime::Dict, kappa_up::Vector{Int}, kappa_down::Vector{Int}, i::Int, j::Int)\n\nCompute the spin flip term 1/2(S+i S-j + S-i S+j) contribution to xprime.\n\nThe function handles two cases:\n\nS+i S-j: when j has up spin and i has down spin\nS-i S+j: when i has up spin and j has down spin\n\nEach case contributes with coefficient 1/2.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}","page":"Reference","title":"KagomeDSL.tilde_U","text":"tilde_U(U::AbstractMatrix, kappa::Vector{Int})\n\n\n\nCreates a tilde matrix by rearranging rows of U according to kappa indices.\n\nParameters:\n\nU: Source matrix of size (n × m)\nkappa: Vector of indices where each non-zero value l indicates that row Rl of U         should be placed at row l of the output\n\nReturns:\n\nA matrix of size (m × m) with same element type as U\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.update_W!-Tuple{AbstractMatrix}","page":"Reference","title":"KagomeDSL.update_W!","text":"update_W!(W::AbstractMatrix; l::Int, K::Int)\n\n\n\nUpdate the W matrix W_Ij = W_Ij - W_Il  W_Kl * (W_Kj - delta_lj)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.update_W_matrices!-Tuple{MC}","page":"Reference","title":"KagomeDSL.update_W_matrices!","text":"update_W_matrices(mc::MC; K_up::Int, K_down::Int, l_up::Int, l_down::Int)\n\n\n\nUpdate the W matrices\n\n\n\n\n\n","category":"method"},{"location":"#KagomeDSL","page":"KagomeDSL","title":"KagomeDSL","text":"","category":"section"},{"location":"","page":"KagomeDSL","title":"KagomeDSL","text":"Documentation for KagomeDSL.","category":"page"}]
}
