var documenterSearchIndex = {"docs":
[{"location":"95-reference/#reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"Reference","title":"Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#KagomeDSL.DoubleKagome-Tuple{Float64, Int64, Int64, Tuple{Bool, Bool}}","page":"Reference","title":"KagomeDSL.DoubleKagome","text":"DoubleKagome(t::Float64, n1::Int, n2::Int, PBC::Tuple{Bool,Bool}; antiPBC=(false,false), trunc=Inf)\n\nConstruct a double unit cell Kagome lattice with 6 sites per unit cell.\n\nUnlike a single unit cell Kagome lattice (which has 3 sites per unit cell forming one triangle), the DoubleKagome lattice contains 6 sites per unit cell arranged in two triangular sublattices. This structure is useful for studying systems with enlarged unit cells or specific magnetic ordering patterns that require the doubled cell geometry.\n\nArguments\n\nt::Float64: Parameter defining the equilateral triangle side length (lattice constant = 2t)\nn1::Int: Number of unit cell repetitions in the a1 direction (must be even)\nn2::Int: Number of unit cell repetitions in the a2 direction  \nPBC::Tuple{Bool,Bool}: Periodic boundary conditions in (a1, a2) directions\nantiPBC::Tuple{Bool,Bool}: Antiperiodic boundary conditions (default: (false, false))\ntrunc::Float64: Truncation parameter (default: Inf, unused in current implementation)\n\nReturns\n\nDoubleKagome: Lattice structure with n1 * n2 * 3 total sites\n\nNotes\n\nThe constraint n1 % 2 == 0 ensures proper tiling of the double unit cell\nTotal number of sites is n1 * n2 * 3 (though each unit cell has 6 sites, n1 counts double-sized cells)\nActual number of unit cells is (n1 ÷ 2) * n2, each containing 6 sites\nLattice vectors: a1 = [4t, 0], a2 = [t, √3*t] \nEach unit cell contains 6 sites arranged in two triangular motifs\n\nExample\n\n# Create a 4×3 DoubleKagome lattice with periodic boundaries\nlat = DoubleKagome(1.0, 4, 3, (true, true))\n# Total sites: 4 * 3 * 3 = 36 sites (2 unit cells × 3 repetitions × 6 sites per unit cell)\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Hamiltonian","page":"Reference","title":"KagomeDSL.Hamiltonian","text":"Hamiltonian\n\nComplete specification of the spinon mean-field Hamiltonian for quantum Monte Carlo simulations.\n\nThis structure contains all information needed for Variational  Monte Carlo calculations of quantum spin liquid properties:\n\nFields\n\nN_up::Int: Number of up-spin spinons (determines spin sector)\nN_down::Int: Number of down-spin spinons\nU_up::Matrix{ComplexF64}: Occupied up-spinon orbitals (columns are eigenvectors)\nU_down::Matrix{ComplexF64}: Occupied down-spinon orbitals\nH_mat::Matrix{ComplexF64}: Single-particle spinon Hamiltonian matrix\nnn::AbstractArray: List of nearest-neighbor bonds for efficient iteration\n\nUsage in Monte Carlo\n\nUup, Udown define the reference state (filled Fermi sea)\nH_mat provides the hopping amplitudes for Monte Carlo updates\nnn specifies which bonds to consider in interaction terms\n\nPhysical Interpretation\n\nRepresents a quantum spin liquid state where spins are fractionalized\nCorrelations arise from quantum fluctuations around the mean-field state\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#KagomeDSL.Hamiltonian-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T<:KagomeDSL.AbstractLattice","page":"Reference","title":"KagomeDSL.Hamiltonian","text":"Hamiltonian(N_up, N_down, lat; link_in=pi_link_in, link_inter=pi_link_inter, B=0.0)\n\nConstruct a complete Hamiltonian structure for quantum Monte Carlo simulations.\n\nThis is the main constructor that builds everything needed for SSE Monte Carlo:\n\nConstructs the single-particle spinon Hamiltonian matrix\nDiagonalizes it to find the occupied orbitals\nExtracts the nearest-neighbor bond structure\nPackages everything for efficient Monte Carlo usage\n\nArguments\n\nN_up::Int, N_down::Int: Number of up/down spinons (determines magnetic sector)\nlat::AbstractLattice: Lattice structure (typically DoubleKagome)\nlink_in: Intra-cell hopping dictionary (default: π-flux pattern)\nlink_inter: Inter-cell hopping dictionary (default: π-flux pattern)\nB::Float64: Magnetic field strength for Peierls phases (default: 0.0)\n\nReturns\n\nHamiltonian: Complete structure ready for Monte Carlo simulations\n\nPhysics Notes\n\nThe choice of Nup, Ndown determines the spin sector being studied\nFor spin-1/2 systems: Nup + Ndown = number of original spins\nDifferent (Nup, Ndown) can access different quantum phases\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.MC","page":"Reference","title":"KagomeDSL.MC","text":"MC <: AbstractMC\n\nMonte Carlo simulation state for quantum spin systems on the Kagome lattice.\n\nFields\n\nHam::Hamiltonian: The Hamiltonian describing the physical system\nkappa_up::Vector{Int}: Configuration vector for up-spin electrons\nkappa_down::Vector{Int}: Configuration vector for down-spin electrons  \nW_up::AbstractMatrix: One-particle Green's function matrix for up-spin electrons\nW_down::AbstractMatrix: One-particle Green's function matrix for down-spin electrons\nW_up_col_cache::AbstractVector: Cache vector for column operations on W_up\nW_up_row_cache::AbstractVector: Cache vector for row operations on W_up\nW_down_col_cache::AbstractVector: Cache vector for column operations on W_down\nW_down_row_cache::AbstractVector: Cache vector for row operations on W_down\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#KagomeDSL.MC-Tuple{AbstractDict}","page":"Reference","title":"KagomeDSL.MC","text":"MC(params::AbstractDict)\n\nCreate a Monte Carlo object from a dictionary of parameters.\n\nThis is the user-facing, high-level constructor that initializes the Monte Carlo simulation state with appropriate dimensions and default configurations.\n\nArguments\n\nparams::AbstractDict: Dictionary containing simulation parameters\n\nRequired Parameters\n\n:n1::Int: Number of unit cells in x-direction\n:n2::Int: Number of unit cells in y-direction  \n:PBC::Tuple{Bool,2}: Periodic boundary conditions\n:N_up::Int: Number of up-spin electrons\n:N_down::Int: Number of down-spin electrons\n\nOptional Parameters\n\n:antiPBC::Tuple{Bool,2}: Anti-periodic boundary conditions (default: (false, false))\n:lattice::Type: Lattice type (default: DoubleKagome)\n:B::Float64: Magnetic field strength (default: 0.0)\n:link_in::Function: Intra-cell linking function (default: pilinkin)\n:link_inter::Function: Inter-cell linking function (default: pilinkinter)\n\nReturns\n\nMC: Initialized Monte Carlo state object\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.MC-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}, AbstractMatrix, AbstractMatrix}","page":"Reference","title":"KagomeDSL.MC","text":"MC(Ham, kappa_up, kappa_down, W_up, W_down)\n\nCreate a Monte Carlo object from its core components.\n\nThis constructor automatically creates the necessary cache arrays for efficient matrix updates. It's primarily used for internal logic and testing purposes.\n\nArguments\n\nHam::Hamiltonian: The Hamiltonian describing the physical system\nkappa_up::Vector{Int}: Initial up-spin configuration vector\nkappa_down::Vector{Int}: Initial down-spin configuration vector\nW_up::AbstractMatrix: Initial one-particle Green's function for up-spin\nW_down::AbstractMatrix: Initial one-particle Green's function for down-spin\n\nReturns\n\nMC: Monte Carlo state object with initialized cache arrays\n\nNote\n\nThe cache arrays enable zero-allocation updates of the Green's function matrices using rank-1 update operations.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.init!-Tuple{MC, MCContext, AbstractDict}","page":"Reference","title":"Carlo.init!","text":"Carlo.init!(mc::MC, ctx::MCContext, params::AbstractDict)\n\nInitialize the Monte Carlo object for Carlo.jl framework integration.\n\nThis function sets up the Monte Carlo simulation by finding an initial non-singular configuration using QR-based initialization.\n\nArguments\n\nmc::MC: Monte Carlo state object\nctx::MCContext: Carlo.jl context object\nparams::AbstractDict: Simulation parameters dictionary\n\nParameters Used\n\n:n1::Int: Number of unit cells in x-direction\n:n2::Int: Number of unit cells in y-direction\n:N_up::Int: Number of up-spin electrons\n\nNote\n\nThis function integrates with the Carlo.jl framework and is called automatically during simulation initialization to prepare the Monte Carlo state.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.measure!-Tuple{MC, MCContext}","page":"Reference","title":"Carlo.measure!","text":"@inline function Carlo.measure!(mc::MC, ctx::MCContext)\n\nMeasures observables during the simulation and collects data.\n\nThis function is called periodically during the simulation to measure physical observables like local energy and collect them for postprocessing.\n\nArguments\n\nmc::MC: Monte Carlo state object\nctx::MCContext: Carlo.jl context object\n\nMeasured Quantities\n\n:OL: Local energy estimator getOL(mc, mc.kappa_up, mc.kappa_down)\n\nNote\n\nMeasurements are taken periodically (every n_occupied sweeps) to reduce correlation between samples and improve measurement efficiency.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.read_checkpoint!-Tuple{MC, HDF5.Group}","page":"Reference","title":"Carlo.read_checkpoint!","text":"Carlo.read_checkpoint!(mc::MC, in::HDF5.Group)\n\nRestore Monte Carlo state from saved checkpoint for simulation continuation.\n\nPurpose: Loads previously saved spin configurations to resume a simulation from a specific state or initialize postprocessing analysis.\n\nArguments\n\nmc::MC: Monte Carlo object to restore (modified in-place)\nin::HDF5.Group: Input HDF5 group containing checkpoint data\n\nRestored Data\n\nkappa_up: Up-spin configuration vector\nkappa_down: Down-spin configuration vector\n\nUsage Contexts\n\nSimulation resumption: Continue interrupted long simulations\nPostprocessing initialization: Start analysis from specific configurations\nReproducibility: Restore exact simulation states\n\nSide Effects\n\nModifies mc.kappa_up and mc.kappa_down in-place\nOverwrites current Monte Carlo configuration completely\n\nNotes\n\nCalled automatically by Carlo.jl when resuming from checkpoints\nEssential for maintaining simulation continuity\nEnables reproducible analysis workflows\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.register_evaluables-Tuple{Type{MC}, Carlo.Evaluator, AbstractDict}","page":"Reference","title":"Carlo.register_evaluables","text":"Carlo.register_evaluables(::Type{MC}, eval::Evaluator, params::AbstractDict)\n\nRegister postprocessing evaluators for final analysis after Monte Carlo simulation.\n\nIMPORTANT: This is purely for postprocessing - these evaluators are executed  at the end of the simulation or during merge operations to compute final observables  from the collected raw measurements. They do NOT affect the Monte Carlo dynamics.\n\nThis function defines how to compute physical observables from the raw measured  data (:OL values) that was collected during the simulation via Carlo.measure!().\n\nArguments\n\n::Type{MC}: Monte Carlo type dispatch\neval::Evaluator: Carlo.jl evaluator for postprocessing computations\nparams::AbstractDict: Simulation parameters containing lattice dimensions\n\nRegistered Evaluables\n\n:energy: Computes the energy per site from local energy measurements\nFormula: energy = OL  ns, where ns = total number of sites\nInput: Raw :OL measurements collected during simulation\nOutput: Normalized energy per site for final results\n\nUsage in Carlo.jl Workflow\n\nDuring simulation: Carlo.measure!() collects raw :OL data\nAfter simulation: This function defines how to postprocess the data\nFinal analysis: Carlo.jl automatically applies these evaluators to compute final results\nMerge operations: Used when combining data from multiple simulation runs\n\nPhysics Notes\n\nOL represents the local energy estimator xHψ_Gxψ_G\nNormalization by ns gives energy per site (intensive quantity)\nEssential for comparing results across different system sizes\n\nPerformance Notes\n\nCalled only once during setup, not during simulation loops\nActual evaluation happens in postprocessing phase\nMinimal computational overhead during Monte Carlo sampling\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.sweep!-Tuple{MC, MCContext}","page":"Reference","title":"Carlo.sweep!","text":"Carlo.sweep!(mc::MC, ctx::MCContext) -> Nothing\n\nPerform one Monte Carlo sweep for Mott state simulation.\n\nThis function implements a two-spin swap update where electrons can exchange positions between different spin states at occupied neighboring sites.\n\nArguments\n\nmc::MC: Monte Carlo state object\nctx::MCContext: Carlo.jl context object\n\nAlgorithm\n\nCalculate number of valid spin exchange moves Zμ\nUse Metropolis acceptance criterion based on move probability\nSelect random neighbor bond for potential exchange\nCalculate acceptance ratio using Green's function matrix elements\nUpdate configurations if move is accepted\nPeriodically re-evaluate W matrices to maintain numerical stability\n\nNote\n\nThe W matrices are re-evaluated periodically (every n_occupied sweeps) to override numerical instability from repeated rank-1 updates. If re-evaluation fails due to singular matrices, a warning is issued and simulation continues.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#Carlo.write_checkpoint-Tuple{MC, HDF5.Group}","page":"Reference","title":"Carlo.write_checkpoint","text":"Carlo.write_checkpoint(mc::MC, out::HDF5.Group)\n\nSave Monte Carlo state for resuming simulations or postprocessing analysis.\n\nPurpose: Serializes the current spin configuration to an HDF5 file for later use in simulation continuation or postprocessing workflows.\n\nArguments\n\nmc::MC: Monte Carlo state to save\nout::HDF5.Group: Output HDF5 group for writing checkpoint data\n\nSaved Data\n\nkappa_up: Current up-spin configuration vector\nkappa_down: Current down-spin configuration vector\n\nUsage Contexts\n\nSimulation checkpointing: Save state for restarting long simulations\nPostprocessing: Preserve final configurations for additional analysis\nData archival: Store representative configurations for later study\n\nNotes\n\nCalled automatically by Carlo.jl during simulation checkpointing\nEssential for resuming interrupted simulations\nEnables analysis of specific configurations post-simulation\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Hmat-Tuple{DoubleKagome}","page":"Reference","title":"KagomeDSL.Hmat","text":"Hmat(\n    lat::DoubleKagome;\n    link_in = pi_link_in,\n    link_inter = pi_link_inter,\n    B = 0.0,\n) -> Matrix{ComplexF64}\n\nConstructs the Spinon Hamiltonian matrix for a DoubleKagome lattice.\n\nThis function calculates the hopping terms within and between unit cells, incorporating a Peierls phase to account for a magnetic field B. The resulting matrix represents the Hamiltonian of the system.\n\nArguments\n\nlat::DoubleKagome: The lattice structure for which to construct the Hamiltonian.\nlink_in: A dictionary defining in-cell hopping terms. Defaults to pi_link_in.\nlink_inter: A dictionary defining inter-cell hopping terms. Defaults to pi_link_inter.\nB::Float64: The magnetic field strength, used to calculate the Peierls phase. Defaults to 0.0.\n\nReturns\n\nMatrix{ComplexF64}: The Hamiltonian matrix for the given lattice and parameters.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Sz-Tuple{Int64, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.Sz","text":"Sz(i::Int, kappa_up::Vector{Int}, kappa_down::Vector{Int}) -> Float64\n\nCalculate the z-component of spin at site i in the spinon representation.\n\nIn the spinon formulation, the original spin operators are written as:\n\nS^zi = 1/2 (f^†{i↑} f{i↑} - f^†{i↓} f_{i↓})\nS^+i = f^†{i↑} f{i↓}, S^-i = f^†{i↓} f{i↑}\n\nwhere f{iσ} are spinon annihilation operators. The constraint is exactly one  spinon per site: n{i↑} + n_{i↓} = 1 (no double occupancy or empty sites).\n\nArguments\n\ni::Int: Site index (1-indexed)\nkappa_up::Vector{Int}: Up-spinon configuration (0 = empty, nonzero = occupied)\nkappa_down::Vector{Int}: Down-spinon configuration\n\nReturns\n\nFloat64: +0.5 for up spin, -0.5 for down spin\n\nExceptions\n\nArgumentError: If site is doubly occupied or empty (violates spinon constraint)\nBoundsError: If i is outside valid range [1, length(kappa_up)]\nDimensionMismatch: If kappaup and kappadown have different lengths\n\nPhysics Notes\n\nThis enforces the constraint that each site has exactly one spinon\nConfigurations violating the constraint (empty or doubly occupied) are unphysical\nUsed in Monte Carlo to measure local magnetization and Ising interactions\nThe spinon constraint is fundamental to the validity of the spin liquid state\n\nPerformance Notes\n\nMarked @inline for performance in Monte Carlo loops\nUses @boundscheck for optional bounds checking\nCalls is_occupied() helper function for spinon occupancy detection\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.SzInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}","page":"Reference","title":"KagomeDSL.SzInteraction!","text":"SzInteraction!(xprime, kappa_up, kappa_down, i, j)\n\nCompute the Ising (S^z S^z) interaction term for the Heisenberg Hamiltonian.\n\nFor the Heisenberg model H = J ∑{<i,j>} (S^+i S^-j + S^-i S^+j + S^zi S^zj), this function handles the S^zi S^z_j term, which is diagonal in the spinon basis.\n\nThe Ising term doesn't change the spinon configuration, so it contributes to the identity component of the operator expansion (stored with key (-1,-1,-1,-1)).\n\nArguments\n\nxprime::Dict: Dictionary storing operator expansion coefficients\nkappa_up::Vector{Int}: Current up-spinon configuration\nkappa_down::Vector{Int}: Current down-spinon configuration  \ni::Int, j::Int: Sites for the interaction\n\nSide Effects\n\nModifies xprime[(-1,-1,-1,-1)] by adding Sz(i) * Sz(j)\n\nPhysics Notes\n\nThis is the \"easy-axis\" part of the Heisenberg interaction\nDiagonal in the occupation basis, doesn't create/destroy spinons\nCombined with spinInteraction!() to give the full Heisenberg model\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.Z-Tuple{AbstractArray, AbstractVector, AbstractVector}","page":"Reference","title":"KagomeDSL.Z","text":"Z(nn::AbstractArray, kappa_up::AbstractVector, kappa_down::AbstractVector) -> Int\n\nCount the number of valid spin exchange moves between neighboring sites.\n\nThis function calculates the number of neighboring site pairs where one site is occupied by an up-spin electron and the other by a down-spin electron, indicating potential spin exchange moves.\n\nArguments\n\nnn::AbstractArray: Array of neighbor bonds (site pairs)\nkappa_up::AbstractVector: Up-spin configuration vector\nkappa_down::AbstractVector: Down-spin configuration vector\n\nReturns\n\nInt: Number of valid spin exchange move opportunities\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.apply_boundary_conditions!-Tuple{AbstractMatrix, KagomeDSL.AbstractLattice, Int64, Int64, Dict, Float64}","page":"Reference","title":"KagomeDSL.apply_boundary_conditions!","text":"apply_boundary_conditions!(tunneling, lat, s1, s2, link_inter, B)\n\nApply boundary conditions and magnetic field effects to inter-cell hopping terms.\n\nThis function modifies the tunneling matrix by adding all possible hopping paths  between sites s1 and s2, considering:\n\nPeriodic/antiperiodic boundary conditions\nPeierls phase factors from magnetic field B\nπ-flux pattern encoded in link_inter dictionary\n\nArguments\n\ntunneling::AbstractMatrix: Hopping matrix to be modified (in-place)\nlat::AbstractLattice: Lattice structure with boundary conditions\ns1::Int, s2::Int: Source and target site indices\nlink_inter::Dict: Inter-cell hopping amplitudes with (label1, label2, dx, dy) keys\nB::Float64: Magnetic field strength for Peierls phase calculation\n\nPhysics Details\n\nPeierls phase: exp(iB/2 * (x1+x2)(y2-y1)) accounts for vector potential A = (0, Bx)\nEach boundary crossing can contribute ±1 phase factor from antiperiodic BC\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.find_initial_configuration!-Tuple{MC, Int64, Int64}","page":"Reference","title":"KagomeDSL.find_initial_configuration!","text":"find_initial_configuration!(mc::MC, ns::Int, N_up::Int)\n\nFind a non-singular initial configuration for Monte Carlo simulation.\n\nThis function uses a deterministic QR-based method to initialize particle configurations and compute the initial Green's function matrices.\n\nArguments\n\nmc::MC: Monte Carlo state object (modified in-place)\nns::Int: Total number of sites in the lattice\nN_up::Int: Number of up-spin electrons\n\nAlgorithm\n\nInitialize configurations using QR decomposition with column pivoting\nConstruct tilde_U matrices from the initialized configurations\nSolve linear systems to compute Green's function matrices\nHandle singular matrix exceptions with informative error messages\n\nThrows\n\nErrorException: If QR-based configuration produces singular matrices, indicating potential rank deficiency in the Hamiltonian\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.getOL-Tuple{Carlo.AbstractMC, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.getOL","text":"getOL(mc::AbstractMC, kappa_up, kappa_down) -> Float64\n\nCompute the local energy estimator for quantum Monte Carlo.\n\nCalculates the observable OL = ⟨x|H|ψG⟩/⟨x|ψ_G⟩, which provides an unbiased estimator of the ground state energy in the Stochastic Series Expansion method.\n\nIn the spinon mean-field framework:\n\n|ψ_G⟩ is the Slater Determinant spinon state (Gutzwiller projected)\n|x⟩ = |κup⟩ ⊗ |κdown⟩ is a particular spinon configuration\nH is the original Heisenberg Hamiltonian (not the mean-field one!)\n\nThe ratio gives the local contribution to the energy from configuration |x⟩.\n\nArguments\n\nmc::AbstractMC: Monte Carlo state containing Wup, Wdown matrices\nkappa_up::Vector{Int}: Current up-spinon configuration\nkappa_down::Vector{Int}: Current down-spinon configuration\n\nReturns\n\nFloat64: Local energy contribution from this configuration\n\nAlgorithm\n\nCompute H|x⟩ using getxprime() to get all reachable configurations\nFor diagonal terms: directly add the Ising contributions\nFor off-diagonal terms: weight by the wavefunction amplitude ratios Wup, Wdown\nSum all contributions to get the local energy\n\nPhysics Notes\n\nThis is the \"local energy\" in variational Monte Carlo terminology\nFluctuations in O_L reflect the quality of the trial wavefunction\nUsed to measure energy and other observables in quantum spin liquids\nThe Hamiltonian H must be the original physical one, not the mean-field approximation\n\nPerformance Notes\n\nCritical function called in every Monte Carlo step\nBounds checking disabled with @inbounds for performance\nUses efficient iteration over pairs() for dictionary access\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.get_boundary_shifts-Tuple{KagomeDSL.AbstractLattice, Int64, Int64}","page":"Reference","title":"KagomeDSL.get_boundary_shifts","text":"get_boundary_shifts(lat::AbstractLattice, s1::Int, s2::Int) -> Vector{Tuple{Int,Int,Float64}}\n\nCalculate all possible lattice vector shifts between sites s1 and s2 under periodic/antiperiodic boundary conditions.\n\nFor quantum spin systems with twisted boundary conditions:\n\nPeriodic BC: ψ(r + L) = ψ(r)\nAntiperiodic BC: ψ(r + L) = -ψ(r)\n\nReturns all equivalent separations considering lattice periodicity, with associated phase factors.\n\nArguments\n\nlat::AbstractLattice: Lattice with boundary condition specifications\ns1::Int, s2::Int: Site indices for the hopping term\n\nReturns\n\nVector{Tuple{Int,Int,Float64}}: List of (dx, dy, sign) tuples where:\ndx, dy: Lattice vector coefficients\nsign: Phase factor (±1) from antiperiodic boundary crossings\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.get_nn-Tuple{AbstractMatrix}","page":"Reference","title":"KagomeDSL.get_nn","text":"get_nn(H_mat::AbstractMatrix) -> Vector{Tuple{Int,Int}}\n\nExtract nearest-neighbor bond list from the Hamiltonian matrix.\n\nFinds all non-zero off-diagonal elements in the upper triangular part of H_mat, which correspond to hopping terms between connected sites. Essential for efficient Monte Carlo sampling since we only need to consider active bonds.\n\nArguments\n\nH_mat::AbstractMatrix: Hamiltonian matrix (typically hermitian)\n\nReturns\n\nVector{Tuple{Int,Int}}: List of (i,j) pairs where i < j and H_mat[i,j] ≠ 0\n\nNotes\n\nOnly upper triangular elements to avoid double-counting\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.get_site_coord-Tuple{KagomeDSL.AbstractLattice, Int64}","page":"Reference","title":"KagomeDSL.get_site_coord","text":"get_site_coord(lat::AbstractLattice, s::Int) -> Vector{Float64}\n\nCalculate the real-space coordinate of site s in the lattice.\n\nCombines the unit cell position with the intra-cell site offset to give the absolute position in real space. Essential for calculating Peierls phases and analyzing spatial correlations.\n\nArguments\n\nlat::AbstractLattice: Lattice structure\ns::Int: Site index (1-indexed)\n\nReturns\n\nVector{Float64}: [x, y] coordinate in real space\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.getxprime-Tuple{Hamiltonian, Vector{Int64}, Vector{Int64}}","page":"Reference","title":"KagomeDSL.getxprime","text":"getxprime(Ham::Hamiltonian, kappa_up, kappa_down) -> Dict{NTuple{4,Int}, Float64}\n\nCompute the action of the Heisenberg Hamiltonian on a spinon configuration.\n\nThis is the core function for Stochastic Series Expansion (SSE) Monte Carlo. Given a spinon configuration |κup, κdown⟩, it computes all configurations  |κ'up, κ'down⟩ that can be reached by applying H, along with their amplitudes.\n\nThe result is H|κ⟩ = Σ_κ' xprime[κ'] |κ'⟩, where xprime encodes the expansion.\n\nArguments\n\nHam::Hamiltonian: Complete Hamiltonian specification\nkappa_up::Vector{Int}: Current up-spinon configuration\nkappa_down::Vector{Int}: Current down-spinon configuration\n\nReturns\n\nDict{NTuple{4,Int}, Float64}: Dictionary mapping configurations to amplitudes\nKey (-1,-1,-1,-1): Diagonal contribution (Ising terms)\nKey (i,lup,j,ldown): Off-diagonal contribution from spin-flip at sites i,j\n\nAlgorithm\n\nIterate over all nearest-neighbor bonds in Ham.nn\nFor each bond, compute Ising (S^z S^z) and transverse (S^+ S^- + S^- S^+) terms\nAccumulate results in xprime dictionary\n\nUsage in Monte Carlo\n\nCalled during each Monte Carlo update to propose new configurations\nThe amplitudes determine acceptance probabilities for updates\nEssential for sampling the quantum mechanical evolution\n\nPhysics Notes\n\n|x⟩ must be a valid Mott state (one spinon per site)\nThe Hamiltonian H is the original Heisenberg model, not the mean-field one\nCombines both diagonal (Ising) and off-diagonal (transverse) contributions\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.init_conf_qr!-Tuple{MC, Int64, Int64}","page":"Reference","title":"KagomeDSL.init_conf_qr!","text":"init_conf_qr!(mc::MC, ns::Int, N_up::Int)\n\nInitialize particle configurations using QR decomposition with column pivoting.\n\nReference: Quantum Monte Carlo Approaches for Correlated Systems (Becca and Sorella, 2017) P130\n\nAs system size increases, Φx becomes exponentially small compared to system size, inversely proportional to the dimension of the Hilbert space.\n\nThe smallness of initial Φx leads to numerical instability in the first computation of the W matrices, but does not affect Markov chain sampling since we always calculate ΦxΦx, which should not be numerically unstable.\n\nThis method selects sites that maximize linear independence from the U matrices to ensure non-singular tilde_U matrices and avoid random trial-and-error initialization.\n\nArguments\n\nmc::MC: Monte Carlo state object (modified in-place)\nns::Int: Total number of sites in the lattice\nN_up::Int: Number of up-spin electrons\n\nAlgorithm\n\nPerform QR decomposition on mc.Ham.U_up' to select N_up most linearly independent rows (sites) for up-spin electrons\nUse remaining unoccupied sites and perform QR decomposition on corresponding subset of mc.Ham.U_down' to select N_down sites for down-spin electrons\n\nNote\n\nThis deterministic approach produces non-singular tilde_U matrices for stable Green's function initialization.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.is_occupied-Tuple{Vector{Int64}, Int64}","page":"Reference","title":"KagomeDSL.is_occupied","text":"is_occupied(kappa::Vector{Int}, l::Int) -> Bool\n\nCheck if site l is occupied in the configuration vector.\n\nArguments\n\nkappa::Vector{Int}: Configuration vector where non-zero values indicate occupation\nl::Int: Site index to check\n\nReturns\n\nBool: true if site l is occupied (kappa[l] ≠ 0), false otherwise\n\nThrows\n\nBoundsError: if l is outside the valid range [1, length(kappa)]\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.orbitals-Tuple{Matrix{ComplexF64}, Int64, Int64}","page":"Reference","title":"KagomeDSL.orbitals","text":"orbitals(H_mat::Matrix{ComplexF64}, N_up::Int, N_down::Int) -> (Matrix{ComplexF64}, Matrix{ComplexF64})\n\nCompute the occupied spinon orbitals for the quantum spin liquid ground state.\n\nIn the spinon mean-field theory:\n\nSpins are fractionalized into spinons (fermionic particles carrying spin-1/2)\nThe Hamiltonian H_mat describes spinon hopping on the lattice\nGround state is a filled Fermi sea of the lowest-energy spinon states\nSeparate up and down spinon sectors (SU(2) symmetry)\n\nArguments\n\nH_mat::Matrix{ComplexF64}: Single-particle spinon Hamiltonian matrix\nN_up::Int: Number of up-spin spinons to fill\nN_down::Int: Number of down-spin spinons to fill\n\nReturns\n\n(U_up, U_down): Matrices whose columns are the occupied spinon orbitals\nU_up: N_up lowest eigenvectors for up spinons\nU_down: N_down lowest eigenvectors for down spinons\n\nPhysics Notes\n\nThe spinon filling typically corresponds to the original spin-1/2 density\nFor a spin-1/2 system: Nup + Ndown = total number of spins\nThe specific choice of Nup, Ndown determines the magnetic properties\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.reevaluateW!-Tuple{MC}","page":"Reference","title":"KagomeDSL.reevaluateW!","text":"reevaluateW!(mc::MC)\n\nRecalculate the one-particle Green's function matrices Wup and Wdown.\n\nThis function reconstructs the Green's functions from the current spin configuration by solving the linear systems involving the tilde_U matrices.\n\nArguments\n\nmc::MC: Monte Carlo state object\n\nAlgorithm\n\nConstruct tilde_U matrices from current kappa configurations\nSolve linear systems: tilde_U_up  I and tilde_U_down  I\nCompute Green's functions: W = U * (tilde_U  I)\n\nNote\n\nU  I is numerically more stable than computing the inverse directly.\n\nThe Green's function matrices W represent the one-particle propagators xcᵢcⱼψxψ for the current configuration.\n\nPeriodic re-evaluation is necessary to override numerical instability that accumulates from repeated rank-1 updates to the Green's function matrices.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.spinInteraction!-Tuple{Dict, Vector{Int64}, Vector{Int64}, Int64, Int64}","page":"Reference","title":"KagomeDSL.spinInteraction!","text":"spinInteraction!(xprime, kappa_up, kappa_down, i, j)\n\nCompute the transverse (spin-flip) part of the Heisenberg interaction.\n\nFor the Heisenberg Hamiltonian H = J ∑{<i,j>} (S^+i S^-j + S^-i S^+j + S^zi S^zj), this function handles the transverse terms S^+i S^-j + S^-i S^+_j.\n\nIn the spinon representation:\n\nS^+i S^-j = f^†{i↑} f{i↓} f^†{j↓} f{j↑} (flips spins at both sites)\nS^-i S^+j = f^†{i↓} f{i↑} f^†{j↑} f{j↓} (flips spins at both sites)\n\nThese terms change the spinon configuration and are the source of quantum fluctuations.\n\nArguments\n\nxprime::Dict: Dictionary storing new configurations and their amplitudes\nkappa_up::Vector{Int}: Current up-spinon configuration\nkappa_down::Vector{Int}: Current down-spinon configuration\ni::Int, j::Int: Sites for the spin-flip interaction\n\nSide Effects\n\nAdds entries to xprime for each allowed spin-flip process\nKey format: (newupsite, olduporbital, newdownsite, olddownorbital)\nAmplitude: -1/2 for each allowed process (negative from Heisenberg coupling)\n\nPhysics Notes\n\nOnly processes that respect the constraint (one spinon per site) are allowed\nCreates quantum entanglement between different spinon configurations\nEssential for accessing quantum spin liquid physics beyond mean-field\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.tilde_U-Tuple{AbstractMatrix, Vector{Int64}}","page":"Reference","title":"KagomeDSL.tilde_U","text":"tilde_U(U::AbstractMatrix, kappa::Vector{Int})\n\nConstruct the tilde_U matrix by selecting and rearranging rows from U.\n\nThe tilde_U matrix is formed by selecting the rows of U corresponding to occupied sites (where kappa[l] ≠ 0) and placing them in the order specified by kappa.\n\nArguments\n\nU::AbstractMatrix: Source matrix of size (n × m) where n is number of sites\nkappa::Vector{Int}: Configuration vector where non-zero values indicate occupied sites\n\nReturns\n\nA matrix of size (m × m) with same element type as U\n\nThrows\n\nDimensionMismatch: If length(kappa) ≠ number of rows in U\nArgumentError: If kappa does not contain exactly m non-zero entries\nBoundsError: If any non-zero kappa value is out of bounds\n\nNote\n\nThis matrix is used in the construction of the one-particle Green's function W.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.unitcell_coord-Tuple{KagomeDSL.AbstractLattice, Int64}","page":"Reference","title":"KagomeDSL.unitcell_coord","text":"unitcell_coord(lat::AbstractLattice, s::Int) -> Vector{Float64}\n\nCompute the real-space coordinate of the unit cell containing site s.\n\nFor DoubleKagome lattice:\n\nSites 1-6 belong to unit cell 1, sites 7-12 to unit cell 2, etc.\nEach unit cell has 6 sites arranged in two triangular motifs\nReturns the coordinate of the unit cell origin in real space\n\nArguments\n\nlat::AbstractLattice: The lattice structure\ns::Int: Site index (1-indexed)\n\nReturns\n\nVector{Float64}: Real-space coordinate of the unit cell origin\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.unitcell_diff-Tuple{KagomeDSL.AbstractLattice, Vector{Float64}, Vector{Float64}}","page":"Reference","title":"KagomeDSL.unitcell_diff","text":"unitcell_diff(lat, unitcell_coord1, unitcell_coord2) -> (Int, Int)\n\nCalculate the lattice vector difference between two unit cells in terms of basis vectors (a1, a2).\n\nThis function solves the linear system: unitcellcoord1 - unitcellcoord2 = dxa1 + dya2 to find integer coefficients (dx, dy) representing the separation in lattice units.\n\nArguments\n\nlat::AbstractLattice: The lattice structure containing basis vectors a1, a2\nunitcell_coord1::Vector{Float64}: Real-space coordinate of first unit cell\nunitcell_coord2::Vector{Float64}: Real-space coordinate of second unit cell\n\nReturns\n\n(dx::Int, dy::Int): Lattice vector coefficients such that coord1 - coord2 = dxa1 + dya2\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.update_W!-Tuple{AbstractMatrix, Int64, Int64, AbstractVector, AbstractVector}","page":"Reference","title":"KagomeDSL.update_W!","text":"update_W!(W::AbstractMatrix, l::Int, K::Int, col_cache::AbstractVector, row_cache::AbstractVector)\n\nPerform a rank-1 update on the Green's function matrix using Sherman-Morrison formula.\n\nArguments\n\nW::AbstractMatrix: Green's function matrix to update\nl::Int: Column index for the update\nK::Int: Row index for the update\ncol_cache::AbstractVector: Pre-allocated cache for column operations\nrow_cache::AbstractVector: Pre-allocated cache for row operations\n\nAlgorithm\n\nImplements the Sherman-Morrison update: W_Ij = W_Ij - W_Il  W_Kl * (W_Kj - δ_lj)\n\nThis represents a rank-1 update to the matrix inverse that maintains the Green's function relationship after a single-particle move.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.update_W_matrices!-Tuple{MC}","page":"Reference","title":"KagomeDSL.update_W_matrices!","text":"update_W_matrices!(mc::MC; K_up::Int, K_down::Int, l_up::Int, l_down::Int)\n\nUpdate the one-particle Green's function matrices using rank-1 updates.\n\nThis function performs simultaneous updates of both Wup and Wdown matrices using the Sherman-Morrison formula for efficient matrix inversion updates.\n\nArguments\n\nmc::MC: Monte Carlo state object\nK_up::Int: Row index for up-spin matrix update\nK_down::Int: Row index for down-spin matrix update  \nl_up::Int: Column index for up-spin matrix update\nl_down::Int: Column index for down-spin matrix update\n\nAlgorithm\n\nPerforms rank-1 updates: W' = W - (W[:,l] * (W[K,:] - δ_{l,:})') / W[K,l] for both spin components using pre-allocated cache arrays.\n\n\n\n\n\n","category":"method"},{"location":"95-reference/#KagomeDSL.update_configurations!-Tuple{Any, Vararg{Int64, 5}}","page":"Reference","title":"KagomeDSL.update_configurations!","text":"update_configurations!(mc, flag::Int, i::Int, site::Int, l_up::Int, l_down::Int)\n\nUpdate both Green's function matrices and configuration vectors for a spin exchange move.\n\nThis function performs the complete update for a spin exchange between sites i and site, including both the Green's function matrices (Wup, Wdown) and the configuration vectors (kappaup, kappadown).\n\nArguments\n\nmc: Monte Carlo state object\nflag::Int: Move type indicator (1 or 2)\ni::Int: First site index\nsite::Int: Second site index\nl_up::Int: Up-spin label to move\nl_down::Int: Down-spin label to move\n\nMove Types\n\nflag = 1: Move up-spin from site i to site, down-spin from site to i\nflag = 2: Move up-spin from site to i, down-spin from site i to site\n\n\n\n\n\n","category":"method"},{"location":"#KagomeDSL","page":"KagomeDSL","title":"KagomeDSL","text":"","category":"section"},{"location":"","page":"KagomeDSL","title":"KagomeDSL","text":"Documentation for KagomeDSL.","category":"page"}]
}
